<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java语言</title>
    <url>/2023/06/13/Java%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="Java基础（面试常考）"><a href="#Java基础（面试常考）" class="headerlink" title="Java基础（面试常考）"></a>Java基础（面试常考）</h1><h2 id="1-Java语言有哪些特点？"><a href="#1-Java语言有哪些特点？" class="headerlink" title="1. Java语言有哪些特点？"></a>1. Java语言有哪些特点？</h2><ul>
<li><p>简单易学</p>
</li>
<li><p>面向对象（封装、继承、多态）</p>
</li>
<li><p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
</li>
<li><p>可靠性</p>
</li>
<li><p>安全性</p>
</li>
<li><p>支持多线程</p>
</li>
<li><p>支持网络编程</p>
</li>
<li><p>编译与解释共存</p>
<p>Java中会将源代码通过javac编译成字节码（class文件），然后运行时JVM会将字节码解释为对应的机器码，最后执行。</p>
<p>在常见的HotSpot虚拟机中，为了避免解释型语言带来的执行效率低问题，采用了JIT compile(just in time compilation)即时编译技术，将运行频率很高的字节码直接编译为机器指令执行来提高性能。</p>
<p>这就是我们为什么经常会说 Java 是编译与解释共存的语言的原因。</p>
</li>
<li><p>会自动进行垃圾回收（GC）</p>
</li>
</ul>
<h2 id="2-JDK、JRE、JVM有什么区别？"><a href="#2-JDK、JRE、JVM有什么区别？" class="headerlink" title="2. JDK、JRE、JVM有什么区别？"></a>2. JDK、JRE、JVM有什么区别？</h2><p>JDK：JDK是Java Development Kit的缩写，它的功能是最全的Java SDK。它拥有JRE所拥有的的一切，还有编译器（Javac）和工具（Javadoc和jdb）。它能够创建和编译程序。</p>
<p>JRE：JRE是Java Runtime Environment的缩写，是Java运行时环境。它是运行已编译Java程序所需的所以内容的集合，包括JVM，Java类库，Java命令和其他一些基础构件。但是它不能用于创建新程序。</p>
<p>JVM：Java虚拟机是运行Java运行字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。</p>
<h2 id="3-Java和C-的区别？"><a href="#3-Java和C-的区别？" class="headerlink" title="3. Java和C++的区别？"></a>3. Java和C++的区别？</h2><ul>
<li>都是面向对象语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，接口是多继承的。C++支持类的多继承</li>
<li>Java有垃圾回收机制，不需要手动释放无用内存</li>
<li>Java语言中没有结束符这一概念。C语言中，字符串或字符数组最后都会有一个额外的字符 ‘ \0 ‘ 来表示结束</li>
</ul>
<h2 id="4-字符型常量和字符串常量有什么区别？"><a href="#4-字符型常量和字符串常量有什么区别？" class="headerlink" title="4. 字符型常量和字符串常量有什么区别？"></a>4. 字符型常量和字符串常量有什么区别？</h2><ul>
<li>字符型常量是用单引号引起来的一个字符，字符串常量是用双引号引起来的零个或多个字符</li>
<li>字符型常量是可以用来进行数学运算的，因为一个字符对应一个ASCII码值。而字符串常量不行，因为字符串常量代表的是地址值</li>
<li>字符型常量占两个字节，字符串常量占多个字节</li>
</ul>
<h2 id="5-抽象类与接口的区别？"><a href="#5-抽象类与接口的区别？" class="headerlink" title="5. 抽象类与接口的区别？"></a>5. 抽象类与接口的区别？</h2><ul>
<li>抽象类与接口都不能直接进行实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量也必须指向实现所有接口的类对象</li>
<li>抽象类必须保证有一个类要去继承它，且这个类只能继承一个抽象类，否则会报错。而接口也要被类去实现。</li>
<li>接口里定义的变量都是被static、final修饰的，抽象类中的变量就是普通变量</li>
<li>抽象类可以没有抽象方法，但是有抽象方法的一定是抽象类</li>
<li>一个类可以实现多个接口，接口与接口是多继承的</li>
<li>接口中没有this指针，没有构造函数，不能拥有实例变量或实例方法</li>
<li>抽象类不能再Java8中的lambda表达式中使用</li>
</ul>
<h2 id="6-字节流与字符流的区别？（StringBuilder和StringBuffer的区别）"><a href="#6-字节流与字符流的区别？（StringBuilder和StringBuffer的区别）" class="headerlink" title="6. 字节流与字符流的区别？（StringBuilder和StringBuffer的区别）"></a>6. 字节流与字符流的区别？（StringBuilder和StringBuffer的区别）</h2><ul>
<li>StringBuffer和StringBuilder都继承自AbstractStringBuilder类，都用来存储字符串，但是不像String那样有final修饰，所以是可变的。</li>
<li>StringBuffer类中方法都加了synchronized同步锁，所以线程安全。而StringBuilder没有加synchronized同步锁，所以线程不安全。</li>
<li>StringBuilder适用于单线程下对字符串缓冲区大量字符串的操作。而StringBuffer适用于多线程下对字符串缓冲区大量字符串的操作。</li>
<li>StringBuilder每次都需要复制一次字符数组，再构造一个字符串。而StringBuffer每次获取toString都会直接使用缓冲区的。toStringCache的值来构造一个字符串。</li>
<li>性能上来说，StringBuilder和StringBuffer都是对变量的操作，对变量的操作是直接对该对象本身进行更改就行，不会进行重复的创建和回收。所以在运行速度上比较快。</li>
</ul>
<h2 id="7-Java中IO流分为几种"><a href="#7-Java中IO流分为几种" class="headerlink" title="7. Java中IO流分为几种"></a>7. Java中IO流分为几种</h2><p>按流向分：输入流、输出流</p>
<p>按操作单元分：字节流、字符流</p>
<p>按流的角色分：节点流、处理流</p>
<p>InputStream &#x2F; Reader：所有的输入流的基类。InputStream是字节输入流，Reader是字符输入流。</p>
<p>OutputStream &#x2F; Writer：所有的输出流的基类。OutputStream是字节输出流，Writer是字符输出流。</p>
<h2 id="8-为什么有了字节流还要有字符流？"><a href="#8-为什么有了字节流还要有字符流？" class="headerlink" title="8. 为什么有了字节流还要有字符流？"></a>8. 为什么有了字节流还要有字符流？</h2><p>字符流是由Java虚拟机将字节转换得到的，这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所有I&#x2F;O流提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</p>
<ul>
<li>音频，视频等媒体文件用字节流比较好</li>
<li>涉及到字符的话使用字符流比较好</li>
</ul>
<h2 id="9-static与final关键字，final修饰的数组可以改变吗？"><a href="#9-static与final关键字，final修饰的数组可以改变吗？" class="headerlink" title="9. static与final关键字，final修饰的数组可以改变吗？"></a>9. static与final关键字，final修饰的数组可以改变吗？</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static可以修饰变量、方法、代码块</p>
<ol>
<li><p><strong>static修饰变量和方法</strong></p>
<ul>
<li><p>被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
</li>
<li><p>被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来</p>
</li>
</ul>
<p>静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，<strong>静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</strong>。类的初始化早于类的new。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的。但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。综上所述：</p>
<ul>
<li><p>&#x3D;&#x3D;静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。&#x3D;&#x3D;</p>
</li>
</ul>
</li>
<li><p><strong>static修饰代码块</strong></p>
<ul>
<li>静态块里面的代码只执行一次，且只在初始化类的时候执行</li>
<li>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</li>
<li>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</li>
<li>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</li>
</ul>
</li>
<li><p><strong>static修饰类</strong></p>
<p>如果static修饰一个类，那这个类一定是一个匿名内部类。像线程池ThreadPoolExecutor中的四种拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy就是静态内部类。</p>
</li>
<li><p><strong>import static</strong></p>
<p>import static是JDK1.5之后的新特性，这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名.资源名，可以直接使用资源名。注意一下，<strong>import static</strong>必须这么写，而不能写成static import。举个例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="number">6</span>     &#123;</span><br><span class="line"><span class="number">7</span>         System.out.println(sin(<span class="number">2.2</span>));</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这么写意味着我导入了Math下的所有静态资源，main函数里面我就可以直接用sin(2.2)而不需要使用Math.sin(2.2)了。注意一下，要写**import static java.lang.Math.***，最后的“.*”不可少，有了这两个字符才意味着导入的是Math下的所有静态资源，写成import static java.lang.Math是有问题的。当然，我们也可以指定只导入某个静态资源，比如只导入Math下sin这个方法而不导入Math下的所有静态资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.sin;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="number">6</span>     &#123;</span><br><span class="line"><span class="number">7</span>         System.out.println(sin(<span class="number">2.2</span>));</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这么写也是没问题的。导入静态变量也是一样，有兴趣的可以自己试一下。对于import static，个人的态度是：</p>
<p>1、简化了一些操作，比如静态导入Math下的所有静态资源，在频繁使用Math类下静态资源的地方，可以少些很多“Math.”</p>
<p>2、降低了代码的可读性</p>
<p>建议在某些场景下导入特定的静态资源，不建议使用“.*”的导入方式。</p>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>使用final修饰的类不能被继承</li>
<li>使用final修饰的方法不能被重写</li>
<li>使用final修饰的变量不可变，如果该变量是基本数据类型，初始化之后成员变量的值不能被改变。如果是引用数据类型，那么它只能指向初始化时的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。</li>
</ul>
<p>使用final关键字的好处：</p>
<ol>
<li>final方法比非final快一些</li>
<li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li>
<li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
<li>使用final关键字，JVM会对方法、变量及类进行优化。</li>
</ol>
<h2 id="10-Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？"><a href="#10-Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？" class="headerlink" title="10. Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？"></a>10. Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？</h2><p>Java泛型是JDK5引入的一个新特性，泛型提供了编译时类型安全检测机制。泛型是的本质是参数化类型。</p>
<p>泛型一般有三种使用方式：泛型类、泛型方法、泛型接口</p>
<p>常用通配符：T、E、K、V、?</p>
<ul>
<li>T（type）：具体的Java类型</li>
<li>E（element）：代表element</li>
<li>K、V（Key、Value）：分别代表Java键值中的key、value</li>
<li>？：表示不确定的Java类型</li>
</ul>
<p>Java的泛型是伪泛型，因为在编译期间，所有的泛型信息都会被擦除，这就是类型擦除。</p>
<h2 id="11-x3D-x3D-和equals的区别？"><a href="#11-x3D-x3D-和equals的区别？" class="headerlink" title="11. &#x3D;&#x3D;和equals的区别？"></a>11. &#x3D;&#x3D;和equals的区别？</h2><p>（1）基本类型比较</p>
<ol>
<li>使用“&#x3D;&#x3D;”比较的是值是否相等</li>
<li>基本数据类型无equals方法</li>
</ol>
<p>（2）引用数据类型</p>
<ol>
<li><p>重写了equals方法，比如String：</p>
<p>第一种情况：使用“&#x3D;&#x3D;”比较的是String的引用是否指向了同一块内存</p>
<p>第二种情况：使用equals方法比较的是String的引用的对象的内容是否相等。</p>
</li>
<li><p>没有重写equals方法：比如User类等自定义类</p>
<p>“&#x3D;&#x3D;”和equals没有区别，比较的都是引用是否指向了同一块内存。</p>
</li>
</ol>
<h2 id="12-hashcode-与equals，为什么重写equals时必须重写hashcode-？"><a href="#12-hashcode-与equals，为什么重写equals时必须重写hashcode-？" class="headerlink" title="12. hashcode()与equals，为什么重写equals时必须重写hashcode()？"></a>12. hashcode()与equals，为什么重写equals时必须重写hashcode()？</h2><p>hashcode()的作用就是获取哈希码，也叫散列码，作用是为了确定该对象在哈希表中的索引位置</p>
<p>如果两个对象相等，那么hashcode一定也相同，调用equals时也都会返回true。但是两个对象有相同的hashcode值，他们也不一定是相等的。因此equals方法被覆盖过，则hashcode方法也必须被覆盖。</p>
<ol>
<li>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率。</li>
<li>保证是同一个对象，因为如果重写了equals没有重写hashcode，会出现equals相同，hashcode不相同的对象。如果重写了hashcode而没有重写equals，那么会出现hashcode相同，equals不相同的对象。</li>
</ol>
<h2 id="13-方法重载和方法重写？"><a href="#13-方法重载和方法重写？" class="headerlink" title="13. 方法重载和方法重写？"></a>13. 方法重载和方法重写？</h2><p>方法重载：重载就是同样的一个方法能够根据输入数据的不同，做出不同的结果处理。即：发生在同一个类中，方法名相同，参数类型不同，个数不同，顺序不同，方法返回值与权限修饰符可以不同。</p>
<p>方法重写：重写就是当子类继承了父类相同的方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类的方法。</p>
<p>方法重写时需要遵循“两同两小一大”</p>
<ul>
<li>两同：方法名相同，参数列表相同</li>
<li>两小：子类方法返回值类型应该小于父类方法返回值类型。子类方法声明抛出的异常类应该比父类方法抛出的异常类更小或相等</li>
<li>一大：子类方法的访问权限应该比父类方法的访问权限更大或相等</li>
</ul>
<h2 id="14-深拷贝、浅拷贝"><a href="#14-深拷贝、浅拷贝" class="headerlink" title="14. 深拷贝、浅拷贝"></a>14. 深拷贝、浅拷贝</h2><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。新对象跟原对象不共享内存，修改新对象不会改到原对象</p>
<p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。浅拷贝只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</p>
<h2 id="15-面向对象的三大特征"><a href="#15-面向对象的三大特征" class="headerlink" title="15. 面向对象的三大特征"></a>15. 面向对象的三大特征</h2><p>封装、继承、多态</p>
<ul>
<li><p>封装：</p>
<p>封装就是把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象内部信息</p>
</li>
<li><p>继承：</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是无法访问，只能拥有。</li>
<li>子类可以拥有自己的属性和方法（对父类进行扩展）</li>
<li>子类可以用自己的方式实现父类的方法（方法重写）</li>
</ol>
</li>
<li><p>多态：</p>
<p>多态，表示一个对象具有多种状态。父类引用指向子类对象。方法重载也是多态的一种体现。</p>
</li>
</ul>
<h2 id="16-import-java和javax的区别"><a href="#16-import-java和javax的区别" class="headerlink" title="16. import java和javax的区别"></a>16. import java和javax的区别</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，&#x3D;&#x3D;javax 当时只是扩展 API 包来使用&#x3D;&#x3D;。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包太麻烦了，最终可能会破坏一堆现有的代码。因此，&#x3D;&#x3D;最终决定 javax 包将成为标准API的一部分。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;所以，实际上java和javax没有区别。这都是一个名字。&#x3D;&#x3D;</p>
<h2 id="17-创建一个对象用什么运算符？对象实例与对象引用有何不同？"><a href="#17-创建一个对象用什么运算符？对象实例与对象引用有何不同？" class="headerlink" title="17. 创建一个对象用什么运算符？对象实例与对象引用有何不同？"></a>17. 创建一个对象用什么运算符？对象实例与对象引用有何不同？</h2><p>使用new关键字创建对象。</p>
<p>new创建的对象实例是在堆内存中的，而对象引用指向对象实例，存放在栈内存中。一个对象引用可以指向一个或零个对象；一个对象可以有n个引用指向它。</p>
<h2 id="18-什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#18-什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="18. 什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>18. 什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><p>方法的返回值就是我们获取到的某个方法体中的代码执行之后产生的结果。</p>
<p>返回值的作用：接收方法体执行结束之后产生的结果，使得其可以用于后续其他的操作</p>
<h2 id="19-什么是哈夫曼树"><a href="#19-什么是哈夫曼树" class="headerlink" title="19. 什么是哈夫曼树"></a>19. 什么是哈夫曼树</h2><p>给定N个权值作为N个<a href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239">叶子结点</a>，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。</p>
<h2 id="20-什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？"><a href="#20-什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？" class="headerlink" title="20. 什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？"></a>20. 什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？</h2><p>满二叉树：除了最后一层没有子节点外，其余每一层上所有节点都有两个子节点的二叉树叫满二叉树。也就是深度为k，且有2的k次方-1个节点的二叉树称为满二叉树。</p>
<p>完全二叉树：如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。</p>
<p>平衡二叉树：任意节点的子树的高度差都小于等于1。</p>
<h2 id="21-反射机制"><a href="#21-反射机制" class="headerlink" title="21. 反射机制"></a>21. 反射机制</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象属性及方法的功能称之为Java语言的反射机制。</p>
<h2 id="22-静态编译和动态编译"><a href="#22-静态编译和动态编译" class="headerlink" title="22. 静态编译和动态编译"></a>22. 静态编译和动态编译</h2><ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：在运行时，确定类型，绑定对象</li>
</ul>
<h2 id="23-反射机制的优缺点？"><a href="#23-反射机制的优缺点？" class="headerlink" title="23. 反射机制的优缺点？"></a>23. 反射机制的优缺点？</h2><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点：性能比直接的Java代码要慢的多，不够安全。</p>
<h2 id="23-反射的应用场景？"><a href="#23-反射的应用场景？" class="headerlink" title="23. 反射的应用场景？"></a>23. 反射的应用场景？</h2><p>JDBC连接数据库使用<code>Class.forName(driver);</code>，通过反射加载数据库驱动</p>
<p>Spring的IOC、AOP中使用了反射</p>
<p>动态配置实例的属性</p>
<p>Web服务器中利用反射调用了Servlet的服务方法</p>
<h2 id="24-什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？"><a href="#24-什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？" class="headerlink" title="24. 什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？"></a>24. 什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？</h2><p>将对象中数据编码为字节序列的过程叫对象的序列化</p>
<p>将字节序列重新反向解码为对象数据的过程称之为反序列化</p>
<p>Java提供了API来实现序列化，但要遵守如下规定：</p>
<ul>
<li>要实现序列化接口（Serializable）</li>
<li>为了保持序列化过程稳定，建议在类中添加序列化版本号</li>
<li>如果不想被序列化，加<strong>transient</strong>关键字</li>
</ul>
<h2 id="25-泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？"><a href="#25-泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？" class="headerlink" title="25. 泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？"></a>25. 泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？</h2><p>泛型的类型擦除是有范围的，定义在类上的泛型信息是不会被擦除的。Java编译器仍在class文件以Signature属性的方式保留了泛型信息。</p>
<p>Type作为顶级接口，Type下还有几种类型，比如TypeVariable，ParameterizedType，WildCardType，GenericArrayType以及Class。通过这些接口，我们就可以在运行时获取泛型相关的信息。</p>
<h2 id="26-Java异常"><a href="#26-Java异常" class="headerlink" title="26. Java异常"></a>26. Java异常</h2><p>所有异常都有一个共同的祖先，Throwable类。Throwable类有两个重要的子类，Exception和Error。</p>
<p>Exception是能被程序本身处理的（try-catch）</p>
<p>Error不能被程序本身处理，只能尽量避免</p>
<p>Exception又可以分为 &#x3D;&#x3D;受检查异常&#x3D;&#x3D; 和 &#x3D;&#x3D;不受检查异常&#x3D;&#x3D; ，除了RuntimeException及其子类外，都是受检查异常，常见的受检查异常有：SQLException、IOException、ClassNotFoundException</p>
<p>常见的不受检查异常有：NullPointException、ArrayIndexOfBoundsException、ClassCastException….</p>
<h2 id="27-finally在哪些情况下不会执行？"><a href="#27-finally在哪些情况下不会执行？" class="headerlink" title="27. finally在哪些情况下不会执行？"></a>27. finally在哪些情况下不会执行？</h2><ul>
<li>在try或finally中用了System.exit()退出程序，则finally不会执行。但是如果System.exit()在异常语句之后，finally还会执行。</li>
<li>程序所在的线程死亡，finally不会执行</li>
<li>关闭CPU，finally不会执行</li>
<li>在进入try之前，就已经返回了，那就不会执行finally</li>
</ul>
<h2 id="28-javac命令和java命令做了什么事情？"><a href="#28-javac命令和java命令做了什么事情？" class="headerlink" title="28. javac命令和java命令做了什么事情？"></a>28. javac命令和java命令做了什么事情？</h2><p>javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。</p>
<p>java：负责运行的部分，会启动jvm加载运行时所需要的类库，并对class文件进行执行。一个文件要被执行，必须要有一个执行的起始点，这个起始点就是main()函数。</p>
<h2 id="29-java数据类型"><a href="#29-java数据类型" class="headerlink" title="29. java数据类型"></a>29. java数据类型</h2><p>基本数据类型：byte、short、int、long、float、double、char、boolean</p>
<p>引用数据类型：类、接口、数组</p>
<p>int：4个字节</p>
<p>short：2个字节</p>
<p>long：8个字节</p>
<p>byte：1个字节</p>
<p>float：4个字节</p>
<p>double：8个字节</p>
<p>char：2个字节</p>
<p>两个数相加，如果一个是double，另一个转换为double。</p>
<p>否则，有一个是float，则另一个转换为float。</p>
<p>否则，有一个是long，则另一个转换为long。</p>
<p>级别从低到高：byte、char、int（这三个平级） - &gt; int - &gt; long - &gt; float - &gt; double</p>
<p>类型转换时可能会出现精度丢失或者数据无法表示</p>
<ul>
<li>精度丢失：float只能有24位来确定精度，而int是32位。int转float可能丢失末尾的有效数字</li>
<li>无法表示：比如float存放一个1e30，转换为int是无法表示的，因为超过了int的最大值</li>
</ul>
<h2 id="30-throw和throws的区别？"><a href="#30-throw和throws的区别？" class="headerlink" title="30. throw和throws的区别？"></a>30. throw和throws的区别？</h2><p>throw用于抛出异常对象，后面跟的是异常对象，throw用于函数内</p>
<p>throws用于抛出异常类，后面跟的是异常类，可以跟多个，用逗号隔开。throws用于方法上（函数上）</p>
<h2 id="31-自动装箱、自动拆箱？"><a href="#31-自动装箱、自动拆箱？" class="headerlink" title="31. 自动装箱、自动拆箱？"></a>31. 自动装箱、自动拆箱？</h2><p>装箱就是自动将基本数据类型转换为包装器类型</p>
<p>拆箱就是自动将包装器类型转换为基本数据类型</p>
<p>int &lt;-&gt; Integer</p>
<p>byte &lt;-&gt; Byte</p>
<p>long &lt;-&gt; Long</p>
<p>float &lt;-&gt; Float</p>
<p>double &lt;-&gt; Double</p>
<p>char &lt;-&gt; Character</p>
<p>boolean &lt;-&gt; Boolean</p>
<p>自动装箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> a; 	<span class="comment">//这一步相当于执行了Integer b = Integer.valueOf(a);</span></span><br></pre></td></tr></table></figure>

<p>自动拆箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> b;		<span class="comment">//这一步相当于执行了int a = b.intValue();</span></span><br></pre></td></tr></table></figure>

<h2 id="32-JDBC操作数据库的基本步骤"><a href="#32-JDBC操作数据库的基本步骤" class="headerlink" title="32. JDBC操作数据库的基本步骤"></a>32. JDBC操作数据库的基本步骤</h2><ol>
<li>加载（注册）数据库驱动（到JVM）</li>
<li>建立（获取）数据库连接</li>
<li>创建（获取）数据库操作对象</li>
<li>定义操作的SQL语句</li>
<li>执行数据库操作</li>
<li>获取并操作结果集</li>
<li>关闭对象，回收数据库资源（关闭结果集 -&gt; 关闭数据库操作对象 -&gt; 关闭连接）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:8080/test?characterEncoding=utf-8&amp;serverTimeZone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动（成功加载后，会将Driver类的实例注册到DriverManager类中）</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//2.获取数据库连接</span></span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.定义SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = 100&quot;</span>;</span><br><span class="line">            <span class="comment">//5.执行数据库操作</span></span><br><span class="line">            rs = stmt.excuteQuery(sql);</span><br><span class="line">            <span class="comment">//6.获取并操作结果集</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//7.关闭对象，回收数据库资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;	<span class="comment">//关闭结果集对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="literal">null</span>) &#123;	<span class="comment">//关闭数据库操作对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;	<span class="comment">//关闭数据库连接对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-Statement和PreparedStatement有什么区别？"><a href="#33-Statement和PreparedStatement有什么区别？" class="headerlink" title="33. Statement和PreparedStatement有什么区别？"></a>33. Statement和PreparedStatement有什么区别？</h2><ul>
<li>PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加安全性（减少SQL注入攻击的可能性）</li>
<li>PreparedStatement中SQL语句是可以带参数的，避免了用字符串拼接SQL语句的麻烦和不安全</li>
<li>当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快</li>
</ul>
<h2 id="34-Class-forName和ClassLoader的区别？"><a href="#34-Class-forName和ClassLoader的区别？" class="headerlink" title="34. Class.forName和ClassLoader的区别？"></a>34. Class.forName和ClassLoader的区别？</h2><p>Class.forName的源码中，有一个forName0方法，这个forName0方法的第二个参数设置为了true，这个参数代表是否对加载的类进行初始化。设置为true时会对类进行初始化，会执行类中的静态代码块，以及对静态变量的赋值等操作。</p>
<p>而ClassLoader并不会对类进行初始化</p>
<h2 id="35-float和double的区别？"><a href="#35-float和double的区别？" class="headerlink" title="35. float和double的区别？"></a>35. float和double的区别？</h2><ul>
<li>float是单精度类型，精度是&#x3D;&#x3D;8&#x3D;&#x3D;位有效数字，占用4个字节，取值范围10^-38^ ~10^38^。</li>
<li>double是双精度类型，精度是&#x3D;&#x3D;17&#x3D;&#x3D;位有效数字，占用8个字节，取值范围是10^-308^~10^308^。</li>
<li>如果不声明，则默认为double类型，如果要使用float的话，需要在后面加 f 。例如：float a &#x3D; 1.0f</li>
<li>float是8位有效数字，第七位会产生四舍五入（5及5一下都舍去）</li>
</ul>
<h2 id="36-既然反射可以拿到private里的值，那private的意义在哪？"><a href="#36-既然反射可以拿到private里的值，那private的意义在哪？" class="headerlink" title="36. 既然反射可以拿到private里的值，那private的意义在哪？"></a>36. 既然反射可以拿到private里的值，那private的意义在哪？</h2><ol>
<li>Java里的private修饰符不是为了绝对的安全设计的，而是对用户常规使用java的一种约束。就好比在饭店厨房门口挂一个闲人免进的牌子，但你还是能够通过其他方法进去。</li>
<li>private的意义是OOP（面向对象编程）的封装概念。</li>
<li>setAccessable(true)，这行代码取消了java权限控制检查，会产生安全隐患，但是提高了反射的速度。</li>
</ol>
<h2 id="37-一个java文件写多个类，会生成多少个class文件？"><a href="#37-一个java文件写多个类，会生成多少个class文件？" class="headerlink" title="37. 一个java文件写多个类，会生成多少个class文件？"></a>37. 一个java文件写多个类，会生成多少个class文件？</h2><p>一个java文件写多个类，除去内部类，剩下的每个普通类都会生成一个class文件。</p>
<h2 id="38-Java语言的6个设计原则。"><a href="#38-Java语言的6个设计原则。" class="headerlink" title="38. Java语言的6个设计原则。"></a>38. Java语言的6个设计原则。</h2><ul>
<li><p>遵循单一职责原则</p>
<p>一个类只专注于做一件事<br>高内聚，低耦合</p>
</li>
<li><p>开放-封闭原则</p>
<p>对拓展开放，对修改关闭（尽可能不动原有代码进行拓展）<br>高内聚，低耦合<br>为达到目的，需对系统进行抽象化设计（关键）</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012552846.png" alt="image-20210708012552846"></p>
</li>
<li><p>里氏代换原则（LSP）</p>
<p>子类必须能够替换它们的基类型，基类与子类可互换，客户端没有察觉情况下<br>低耦合<br>很容易实现同一父类下的各个子类的互换，而客户端可以毫不察觉</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012701645.png" alt="image-20210708012701645"></p>
<p>士兵只能使用WeaponGun，而无法使用ToyGun杀敌，如果使用ToyGun将会出错。这就是里氏替换原则。</p>
</li>
<li><p>依赖倒置原则</p>
<p>这个是开闭原则的基础。</p>
<p>具体内容：面向接口编程，依赖于抽象而不依赖于细节。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p>使用多个专一功能的接口比使用一个总接口总要好，但不能过度<br>一个接口不能过于臃肿<br>高内聚<br>会使一个软件系统功能拓展时，修改的压力不会影响到别的对象那去</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012807116.png" alt="image-20210708012807116"></p>
<p>Model只要满足好身材这个条件，就有可能成为模特，漂亮女孩满足好身材和好。AngelaBaby即有好身材又好。</p>
</li>
<li><p>迪米特法则（Law of Demeter）</p>
<p>又叫最少知识原则<br>对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系<br>低耦合<br>类知道其他类应尽量少<br>类可以访问其他类的方法或者属性也应尽量少</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012836504.png" alt="image-20210708012836504"></p>
<p>如果Lily和Jack自己做hamburg那么就会与Vegetable、Meat、Bread产生千丝万缕关系。上图，则由KFC来做，这样Lily和Jack就只与Hamburg有关关联，与材料就没有关联了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>前端</title>
    <url>/2023/06/13/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="CSS学习"><a href="#CSS学习" class="headerlink" title="CSS学习"></a>CSS学习</h1><p>测试测试</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题汇总（一）</title>
    <url>/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、OSI七层模型、TCP-x2F-IP四层模型与五层模型介绍"><a href="#一、OSI七层模型、TCP-x2F-IP四层模型与五层模型介绍" class="headerlink" title="一、OSI七层模型、TCP&#x2F;IP四层模型与五层模型介绍"></a>一、OSI七层模型、TCP&#x2F;IP四层模型与五层模型介绍</h1><p>OSI七层模型（从顶到下）分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。</p>
<p>TCP&#x2F;IP四层模型（从顶到下）分别是：应用层、传输层、网际层、网络接口层。</p>
<p>五层模型（从顶到下）分别是：应用层、传输层、网络层、数据链路层、物理层。</p>
<p>OSI七层模型中每一层的功能与常见协议如下：</p>
<ul>
<li><p><strong>应用层：</strong>通过应用进程间的交互来完成特定的网络应用。</p>
<p>常见协议：SMTP（简单邮件传输协议）、FTP（文件传输协议）、DNS（域名系统）、HTTP（超文本传输协议）、POP3（邮局协议）、Telnet（远程登录协议）…</p>
</li>
<li><p><strong>表示层：</strong>主要用于处理两个通信系统间信息交换的表示方式，包括：数据的加密和解密、数据的压缩和解压缩、数据的编码和解码等。</p>
</li>
<li><p><strong>会话层：</strong>建立、维护和重连应用程序之间的会话。</p>
</li>
<li><p><strong>传输层：</strong>为两台主机进程之间的通信提供通用的数据传输服务。</p>
<p>常见协议：TCP（传输控制协议）、UDP（用户数据报协议）。</p>
</li>
<li><p><strong>网络层：</strong>把传输层产生的报文段或用户数据报封装成分组和包进行传送。此外，还会寻找合适的网间路由和交换节点，保证数据的及时传输。</p>
<p>常见协议：IP（网际互联协议）、IPv6（网际互联协议第6版），ICMP（互联网控制信息协议）、IGMP（互联网组管理协议）、OSPF（开放最短路径优先协议）…</p>
</li>
<li><p><strong>数据链路层：</strong>将网络层传下来的IP数据报组装成帧，在两个相邻节点之间的链路上进行帧的传输。每一帧包括必要的控制信息（同步信息、差错控制、地址信息等）。</p>
</li>
<li><p><strong>物理层：</strong>利用物理传输介质为数据链路层提供物理连接，实现相邻计算机之间比特流的透明传输。</p>
</li>
</ul>
<p><img src="/img/article_content_img/osi-model.png" alt="OSI七层模型图"></p>
<h1 id="二、常见协议简介"><a href="#二、常见协议简介" class="headerlink" title="二、常见协议简介"></a>二、常见协议简介</h1><ul>
<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）：</strong> 基于TCP协议，使用“客户端&#x2F;服务器”工作模式，是一种用于传输超文本和多媒体内容的协议，主要是为Web浏览器与Web服务器之间的通信而设计的。当我们使用浏览器浏览网页时，网页就是通过HTTP请求进行加载的。HTTP是一种<strong>无状态</strong>协议，即无法记录客户端用户的状态。因此，一般采用会采用Session来记录客户端用户的状态。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）：</strong>基于TCP协议，是一种用于发送电子邮件的协议。（注：SMTP只负责发送邮件，不负责接收邮件）</li>
<li><strong>FTP（File Transfer Protocol，文件传输协议）：</strong>基于TCP协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。但FTP是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，若要传输敏感数据，建议使用SFTP（<strong>SSH File Transfer Protocol，安全文件传输协议</strong>）。</li>
<li><strong>Telnet（远程登录协议）：</strong>基于TCP协议，用于通过一个终端登录到其他服务器。但Telnet也是一种不安全的协议，因为所有数据都会以明文的形式传送。</li>
<li><strong>DNS（Domain Name System，域名系统）：</strong>基于UDP协议，用于IP地址与域名映射。</li>
<li><strong>POP3（Post Office Protocol - Version 3，邮局协议版本3）：</strong>基于TCP协议，负责邮件的接收。</li>
<li><strong>IMAP（Internet Mail Access Protocol，邮件访问协议）：</strong>基于TCP协议，负责邮件的接收。相比于POP3协议，IMAP协议支持邮件搜索、标记、分类、归档等功能，并且支持在多个设备之间同步邮件状态。</li>
<li><strong>TCP（Transmission Control Protocol，传输控制协议）：</strong>提供面向连接的、可靠的、有状态的数据传输服务。</li>
<li><strong>UDP（User Datagram Protocol，用户数据报协议）：</strong>提供无连接的，不可靠的，无状态的数据传输服务。</li>
<li><strong>IP（Internet Protocol，网际互联协议）：</strong>主要用来定义数据包格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前IP协议主要有两种，分别为IPv4和IPv6。</li>
<li><strong>ICMP（Internet Control Message Protocol，互联网控制信息协议）：</strong>一种用于传输网络状态和错误信息的协议，常用于网络诊断和故障排除。例如：<code>ping</code>命令就是使用ICMP协议来测试网络连通性。</li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）：</strong>用于解决IP地址与物理地址（MAC地址）相互转化的问题。</li>
<li><strong>RIP（Routing Information Protocol，路由信息协议）：</strong>一种内部网关协议，也是一种动态路由协议。该协议基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
</ul>
<h1 id="三、常见协议端口号"><a href="#三、常见协议端口号" class="headerlink" title="三、常见协议端口号"></a>三、常见协议端口号</h1><ul>
<li>Telnet（远程登录协议）：23</li>
<li>FTP（文件传输协议）：20、21</li>
<li>SMTP（简单邮件传输协议）：25</li>
<li>POP3（邮局协议版本3）：110</li>
<li>DNS（域名系统）：53</li>
<li>SSH（安全外壳协议）：22</li>
<li>HTTP（超文本传输协议）：80</li>
<li>HTTPS（安全的超文本传输协议）：443</li>
</ul>
<h1 id="四、从输入URL到页面展示的全过程"><a href="#四、从输入URL到页面展示的全过程" class="headerlink" title="四、从输入URL到页面展示的全过程"></a>四、从输入URL到页面展示的全过程</h1><ol>
<li><strong>DNS解析：</strong>浏览器查找所输入域名的IP地址。</li>
<li><strong>TCP连接：</strong>浏览器与目标服务器通过“三次握手”建立TCP连接。</li>
<li><strong>发送请求：</strong>浏览器通过HTTP协议发送请求。</li>
<li><strong>返回报文：</strong>服务器处理请求并将处理结果及相应的视图返回给浏览器。</li>
<li><strong>解析、渲染页面：</strong>浏览器解析并渲染页面。若遇到对js、css、图片等静态资源的引用，则重复上述步骤，向服务器请求这些资源。</li>
<li><strong>TCP断开连接：</strong>浏览器与目标服务器通过“四次挥手”断开连接。</li>
</ol>
<h1 id="五、HTTP状态码"><a href="#五、HTTP状态码" class="headerlink" title="五、HTTP状态码"></a>五、HTTP状态码</h1><table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100（Continue）</td>
<td align="center">请求者应当继续发起请求。表示服务器已经收到请求的第一部分，正在等到其余部分。例如：浏览器使用POST方式向服务器发起请求时，要先进行“三次握手”，然后服务器返回100状态码，浏览器才会再次发送数据。</td>
</tr>
<tr>
<td align="center">200（OK）</td>
<td align="center">服务器已经成功处理请求</td>
</tr>
<tr>
<td align="center">201（Created）</td>
<td align="center">请求被成功处理并且在服务端创建了一个新的资源。例如：通过POST请求创建一个新的用户。</td>
</tr>
<tr>
<td align="center">202（Accepted）</td>
<td align="center">服务端已经接收到了请求，但是还没有进行处理。</td>
</tr>
<tr>
<td align="center">204（No Content）</td>
<td align="center">服务端已经成功处理了请求，但是没有返回任何内容。一般用于只关注处理结果是否成功的场景。</td>
</tr>
<tr>
<td align="center">301（Moved Permanently）</td>
<td align="center">永久重定向。例如：网站网址进行了变更。</td>
</tr>
<tr>
<td align="center">302（Moved Temporarily）</td>
<td align="center">暂时重定向。例如：网站的某些资源原本确实存在，但是被暂时移动到其他的URI下。</td>
</tr>
<tr>
<td align="center">400（Bad Request）</td>
<td align="center">发送的HTTP请求存在问题。例如：请求参数不合法、请求方法错误等。</td>
</tr>
<tr>
<td align="center">401（Unauthorized）</td>
<td align="center">未进行认证，但却访问了需要认证之后才能访问的资源。</td>
</tr>
<tr>
<td align="center">403（Forbidden）</td>
<td align="center">拒绝访问。一般用于针对非法请求。</td>
</tr>
<tr>
<td align="center">404（Not Found）</td>
<td align="center">请求的资源在服务端未找到。</td>
</tr>
<tr>
<td align="center">409（Conflict）</td>
<td align="center">请求的资源与服务端当前的状态存在冲突，请求无法被处理。</td>
</tr>
<tr>
<td align="center">410（Gone）</td>
<td align="center">服务器上某个资源被永久性的删除。</td>
</tr>
<tr>
<td align="center">500（Internal Server Error）</td>
<td align="center">服务端内部出错。例如：服务端抛异常，且这个异常没有被处理（异常捕获）。</td>
</tr>
<tr>
<td align="center">502（Bad Gateway）</td>
<td align="center">网关将请求转发到服务端，但服务端返回的是一个错误的响应。</td>
</tr>
</tbody></table>
<h1 id="六、HTTP和HTTPS的区别"><a href="#六、HTTP和HTTPS的区别" class="headerlink" title="六、HTTP和HTTPS的区别"></a>六、HTTP和HTTPS的区别</h1><ul>
<li><strong>端口号不同：</strong>HTTP端口号为80，HTTPS端口号为443。</li>
<li><strong>URL前缀不同：</strong>HTTP的URL前缀是<code>http://</code>，HTTPS的URL前缀是<code>https://</code>。</li>
<li><strong>安全性不同：</strong>HTTP是明文传输，客户端和服务器都无法验证对方的身份，所以安全性很低。而HTTPS是运行在SSL&#x2F;TLS之上的，所有内容都经过加密，加密采用对称加密，而对称加密的秘钥又是采用服务端证书进行了非对称加密，所以安全性很高。不过HTTPS比HTTP更耗费服务器资源。</li>
</ul>
<h1 id="七、HTTP-x2F-1-0和HTTP-x2F-1-1的区别"><a href="#七、HTTP-x2F-1-0和HTTP-x2F-1-1的区别" class="headerlink" title="七、HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别"></a>七、HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别</h1><ul>
<li><p><strong>连接方式：</strong>HTTP1.0默认使用短连接，但可以通过设置请求头的<code>Connection</code>属性为<code>Keep-Alive</code>来实现长连接。HTTP&#x2F;1.1默认使用长连接。实现长连接需要客户端和服务端均支持长连接。</p>
</li>
<li><p><strong>状态码：</strong>HTTP&#x2F;1.0仅定义了16种状态码。而HTTP&#x2F;1.1新加入了大量的状态码。例如：409（Conflict）、410（Gone）、100（Continue）、206（Partial Content）等。</p>
</li>
<li><p><strong>缓存策略：</strong>HTTP&#x2F;1.0中主要使用Header里的<code>If-Modified-Since</code>和<code>Expires</code>作为缓存判断的标准，而HTTP&#x2F;1.1引入了更多的缓存控制策略，例如：<code>Entity tag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code>等。</p>
</li>
<li><p><strong>带宽：</strong>HTTP&#x2F;1.0中存在一些浪费带宽的情况，例如：客户端只需要某个对象的一部分，而服务器却将整个对象都传送过来了，并且不支持断点续传功能。而HTTP&#x2F;1.1引入了范围请求机制，当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，可以在请求中加入<code>range</code>头部，以请求数据的一部分，对应的状态码为206（Partial Content）。此外，HTTP&#x2F;1.1在针对大文件请求时也做了优化，引入了100（Continue）状态码，当服务器不愿意响应这种大文件请求时，100状态码可以作为指示请求是否会被正常响应的标志。过程如下图：</p>
<p><img src="/img/article_content_img/http1.1_continue1.png" alt="http1.1_continue1"></p>
<p><img src="/img/article_content_img/http1.1_continue2.png" alt="http1.1_continue1"></p>
</li>
<li><p><strong>Host域：</strong>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP&#x2F;1.0不支持。例如：有一个资源的URL是<code>http://test1.org/index.html</code>，对于HTTP&#x2F;1.0来说，请求的是<code>GET /index.html</code>，即没有加入主机名。这样的报文送到服务端，服务器无法理解客户端想要请求的真正网址。而对于HTTP&#x2F;1.1来说，请求的是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: test1.org</span><br></pre></td></tr></table></figure>

<p>这样，服务器就知道客户端想请求的真正网址了。</p>
</li>
</ul>
<h1 id="八、HTTP-x2F-1-1和HTTP-x2F-2-0的区别"><a href="#八、HTTP-x2F-1-1和HTTP-x2F-2-0的区别" class="headerlink" title="八、HTTP&#x2F;1.1和HTTP&#x2F;2.0的区别"></a>八、HTTP&#x2F;1.1和HTTP&#x2F;2.0的区别</h1><ul>
<li><strong>IO多路复用：</strong>HTTP&#x2F;1.1使用的是串行方式，每个请求和响应都需要独立的连接。HTTP&#x2F;2.0引入IO多路复用技术，支持在同一个连接上并发处理多个请求，并且并发请求的数量比HTTP&#x2F;1.1大了好几个量级。因此，在处理多个请求时HTTP&#x2F;2.0更加高效，减少了网络延迟，提高了性能。</li>
<li><strong>二进制帧：</strong>HTTP&#x2F;1.1使用文本格式的报文进行数据传输，而HTTP&#x2F;2.0使用二进制帧进行数据传输，二进制帧更加紧凑和高效，减少了传输的数据量和宽带消耗。</li>
<li><strong>头部压缩：</strong>HTTP&#x2F;1.1中，请求和响应都是由自由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩后的二进制文件，但状态行和头部没有经过任何压缩，直接以纯文本的形式传输。随着Web功能越来越复杂，每个页面产生的请求越来越多，导致消耗在头部的流量越来越多，尤其每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。所以在HTTP&#x2F;2.0中采用HPACK算法对头部数据进行压缩，体积小了，传输速度就更快了。</li>
<li><strong>服务器推送：</strong>对于HTTP&#x2F;1.1来说，想要获取任何资源，客户端都必须自己向服务端发送请求，这样就会导致客户端请求次数过多。而HTTP&#x2F;2.0引入了服务器推送技术（Sever Push），它允许服务器推送资源给浏览器，即当客户端请求一个资源时，服务器会将其他相关的资源一并推送给客户端，从而减少了客户端的请求次数和延迟。</li>
</ul>
<h1 id="九、HTTP-x2F-2-0和HTTP-x2F-3-0的区别"><a href="#九、HTTP-x2F-2-0和HTTP-x2F-3-0的区别" class="headerlink" title="九、HTTP&#x2F;2.0和HTTP&#x2F;3.0的区别"></a>九、HTTP&#x2F;2.0和HTTP&#x2F;3.0的区别</h1><ul>
<li><strong>传输协议：</strong>HTTP&#x2F;2.0是基于TCP的协议，HTTP&#x2F;3.0新增了QUIC（Quic UDP Internet Connections）协议来实现可靠的传输，提供与SSL&#x2F;TLS相当的安全性，具有较低的连接和传输延迟。</li>
<li><strong>连接建立：</strong>由于HTTP&#x2F;2.0是基于TCP的协议，因此建立连接需要进行“三次握手”过程（一般是3个RTT）。而HTTP&#x2F;3.0是基于UDP的协议，因此避免了“三次握手”过程，它允许在第一次连接时发送数据（0个RTT）。</li>
<li><strong>队头阻塞：</strong>HTTP&#x2F;2.0采用了IO多路复用，即多个请求复用一个TCP连接，因此一旦发生丢包，就会阻塞所有HTTP请求。而HTTP&#x2F;3.0基于QUIC协议的特性，在一定程度上解决了队头阻塞问题。一个连接建立多个不同的数据流，这些数据流之间互不影响，当某个数据流发生了丢包，其他数据流不会受到影响（本质上是多路复用+轮询）。</li>
<li><strong>错误恢复：</strong>HTTP&#x2F;3.0相比于HTTP&#x2F;2.0来说，具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而HTTP&#x2F;2.0需要依赖于TCP的错误恢复机制。</li>
<li><strong>安全性：</strong>HTTP&#x2F;2.0使用TLS协议进行加密，而HTTP&#x2F;3.0基于QUIC协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li>
</ul>
<h1 id="十、HTTPS（SSL-x2F-TLS）的连接过程是怎么样的"><a href="#十、HTTPS（SSL-x2F-TLS）的连接过程是怎么样的" class="headerlink" title="十、HTTPS（SSL&#x2F;TLS）的连接过程是怎么样的"></a>十、HTTPS（SSL&#x2F;TLS）的连接过程是怎么样的</h1><ol>
<li><p>TLS层是在TCP层之上的，因此在建立TLS之前，需要先建立TCP连接。</p>
</li>
<li><p>客户端向服务器发送建立TLS请求，请求内容包括：客户端支持的SSL&#x2F;TLS协议版本号、客户端产生的随机数client-random、客户端支持的加密规则等。</p>
</li>
<li><p>服务端收到客户端的请求后，向客户端发出响应，响应内容包括：确认SSL&#x2F;TLS协议版本号、服务器产生的随机数server-random、确认的加密规则、服务器的数字证书。</p>
</li>
<li><p>校验数字证书，如果校验失败，连接断开。如果校验成功，则继续步骤5。</p>
</li>
<li><p>如果校验通过，客户端会从数字证书中取出服务器的公钥，然后使用这个公钥去加密要传输的报文，之后向服务器发送以下信息：</p>
<ul>
<li>Client Key Exchange：基于前面提到的两个随机数，再生成第三个随机数pre-master，然后通过CA证书中的公钥对pre-master加密，得到pre-master key，发送给服务器。</li>
<li>Change Cipher Spec：加密通信算法改变通知，表示客户端随后的信息都将用<strong>会话秘钥</strong>加密通信。</li>
<li>Encrypted handshake message：这一步对应的是客户端的Finish消息，客户端将前面握手的消息生成摘要，再用协商好的会话秘钥进行加密，这是客户端发出的第一条加密消息，服务端收到后，会用会话秘钥解密，如果能解出来说明前面协商的秘钥是一致的，至此，客户端的握手完成。</li>
</ul>
<blockquote>
<p>会话秘钥是用双方协商的加密算法和三个随机数生成的</p>
</blockquote>
</li>
<li><p>服务器使用自己的CA证书的私钥对pre-master key解密，得到pre-master，再计算出会话秘钥，随后向客户端发送以下信息：</p>
<ul>
<li>Change Cipher Spec：加密通信算法改变通知，表示服务端随后的信息都将用会话秘钥加密通信。</li>
<li>Encrypted handshake message：这一步对应的是服务端的Finish消息，服务端会将握手过程消息生成摘要，然后再用会话秘钥加密，这是服务器发出的第一条加密消息，客户端接收后会用会话秘钥解密，能解出来说明协商成功。</li>
</ul>
</li>
<li><p>至此，整个SSL&#x2F;TLS的握手阶段全部结束，TCP四次挥手断开连接。</p>
</li>
</ol>
<h1 id="十一、HTTP协议如何保持状态"><a href="#十一、HTTP协议如何保持状态" class="headerlink" title="十一、HTTP协议如何保持状态"></a>十一、HTTP协议如何保持状态</h1><p>HTTP是一种无状态协议，即不会对请求和响应之间的通信状态进行保存。因此，当我们需要保存用户状态时，需要采用Session机制。Session的主要作用就是通过服务端记录用户的状态，典型场景是购物车，当添加商品到购物车时，系统本来是不知道是哪个用户操作的（HTTP无状态），但由于服务端会给每个用户创建特定的Session，以此来标识并跟踪用户，这样系统便知道是哪个用户进行添加购物车的操作了。</p>
<p>Session在服务端一般会保存在数据库和内存（例如：Redis）。然后通过在Cookie中附加SessionID的方式来实现Session跟踪。如果Cookie被禁用了，则可以利用URL重写，把SessionID直接附加到URL路径的后面。</p>
<h1 id="十二、Cookie和Session是如何配合的"><a href="#十二、Cookie和Session是如何配合的" class="headerlink" title="十二、Cookie和Session是如何配合的"></a>十二、Cookie和Session是如何配合的</h1><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名。</p>
<p>用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务器，服务器会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到了，说明用户已经登录，可执行后续操作。</p>
<h1 id="十三、Cookie和Session的区别"><a href="#十三、Cookie和Session的区别" class="headerlink" title="十三、Cookie和Session的区别"></a>十三、Cookie和Session的区别</h1><ul>
<li><strong>存储位置：</strong>Cookie的数据信息保存在客户端浏览器中。Session的数据信息保存在服务器上。</li>
<li><strong>存储容量：</strong>单个Cookie保存的数据小于等于4KB，一个站点最多保存20个Cookie。对于Session来说，没有上限，但是出于对服务器的性能考虑，Session内不要存放过多的东西，并且设置Session删除机制。</li>
<li><strong>存储方式：</strong>Cookie中只能保存ASCII字符串，如果要存储非ASCII字符串还要对其编码。Session中能够存储任何类型的数据。</li>
<li><strong>隐私策略：</strong>Cookie存储在浏览器中，对客户端是可见的。Session存储在服务器上，对客户端是透明的（不可见）。</li>
<li><strong>跨域支持：</strong>Cookie支持跨域名访问，Session不支持跨域名访问。</li>
<li><strong>生命周期：</strong>Cookie保存在硬盘中，通过设置<code>maxAge</code>属性来设置生命周期，如果是比较大的正整数，那么关闭浏览器，Cookie还是存在的。Session保存在服务器中，设置<code>maxInactiveInterval</code>属性值来确定Session的有效期，并且Session虽然没有从服务器中消亡，但也失效了。</li>
<li><strong>浏览器支持：</strong>如果浏览器禁用了Cookie，那么Cookie是无用的。而Session可以通过url重写来进行会话跟踪。</li>
</ul>
<h1 id="十四、HTTP的GET和POST请求方式的区别"><a href="#十四、HTTP的GET和POST请求方式的区别" class="headerlink" title="十四、HTTP的GET和POST请求方式的区别"></a>十四、HTTP的GET和POST请求方式的区别</h1><ul>
<li>GET是获取数据，POST是提交数据。</li>
<li>我们平时在浏览器上输入网址直接访问的方式就是GET方式。而form表单提交，method里面设置的post，则是POST方式。</li>
<li>GET的访问时候的参数是在URL里面的，比如<code>?username=111&amp;password=123</code>，POST提交的参数是在请求体里面的。而且在请求体里面的会进行urlencode编码，所以这两者相比较来说，POST更安全。但其实从数据传输角度来说这两种都不安全，如果想要安全的，需要使用HTTPS协议。</li>
<li>GET有浏览器缓存记录，而POST没有。</li>
<li>GET方式访问的URL是可以保存为浏览器书签的，POST不可以。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET请求的URL的编码格式采用的是ASCII编码，而不是unicode，所以所有的非ASCII字符都要编码之后再传输。</li>
<li>GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li>
<li>GET只能传输ASCLL字符，不能进行编码。POST传输的时候是放在HTTP的请求体之中的，并且是经过urlencode编码的所以是相对安全的。POST对数据类型没有限制限制，二进制数据也是可以的。</li>
<li>HTTP协议并没有对GET和POST的长度做限制，其实是浏览器限制了他们传输大小。URL地址是有长度限制的，浏览器不同，长度限制的具体数值也是不一样的。比如IE浏览器是2083字节。需要注意的是这些仅仅是URL地址栏的长度限制。理论上来说POST的长度是没有限制的，但是受服务器的配置限制或者内存大小的限制，造成了实际开发中POST也是有数据长度的限制的。</li>
<li>因为GET是获取数据，所以GET请求是安全且幂等的，是无害的。这个安全指得是对数据不会造成影响。幂等就是无论获取多少次数据得到的资源都是一样的。POST是向服务器传输数据，数据会被重新提交，所以就会有对原有的数据造成伤害。</li>
</ul>
<h1 id="十五、URL和URI的区别"><a href="#十五、URL和URI的区别" class="headerlink" title="十五、URL和URI的区别"></a>十五、URL和URI的区别</h1><p>URI是统一资源标识符，可以唯一标识一个资源。</p>
<p>URL是统一资源定位符，它是具体的URI，即它既可以唯一标识一个资源，还提供了定位该资源的信息。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题记录（链表）</title>
    <url>/2023/06/16/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h1><h2 id="1、合并两个有序链表"><a href="#1、合并两个有序链表" class="headerlink" title="1、合并两个有序链表"></a>1、合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code>和一个当前指针<code>cur</code>，<code>cur</code>指向<code>virtualNode</code>。</li>
<li>两个链表同时遍历，当<code>list1.val</code>小于等于<code>list2.val</code>的时候，创建一个新结点，值为<code>list1.val</code>，插入到新链表中。</li>
<li>当两个链表中只要有一个链表遍历完时，结束循环。未遍历完的链表直接插到新链表中即可。</li>
<li>最终返回<code>virtualNode.next</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个单链表：</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     // 声明节点的值为val</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 声明节点的下一个节点为next</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 无参构造、含有val参数的有参构造、含有val、next参数的有参构造</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除排序链表中的重复元素"><a href="#2、删除排序链表中的重复元素" class="headerlink" title="2、删除排序链表中的重复元素"></a>2、删除排序链表中的重复元素</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></p>
<p>思路：</p>
<ul>
<li>定义一个当前指针<code>cur</code>指向头结点</li>
<li>如果链表不存在（<code>cur== null</code>）或者链表只有一个结点（<code>cur.next == null</code>），直接返回头结点<code>head</code>。</li>
<li>否则，判断<code>cur</code>指向的当前结点的值与下一个结点的值是否相等。若相等，说明下一个结点是重复结点，则删除下一个结点（断链：<code>cur.next = cur.next.next</code>）；若不相等，说明不是重复结点，当前指针<code>cur</code>右移。</li>
<li>所有结点都遍历完后（此时当前指针<code>cur</code>要么为<code>null</code>了，要么<code>cur.next</code>为<code>null</code>了），直接返回头结点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、判断链表是否有环"><a href="#3、判断链表是否有环" class="headerlink" title="3、判断链表是否有环"></a>3、判断链表是否有环</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
<p>思路：</p>
<ul>
<li>使用快慢指针（<code>fast</code>、<code>slow</code>）。</li>
<li>初始时刻，快、慢指针均指向头结点<code>head</code>。</li>
<li><code>fast  != null</code>并且<code>fast.next != null</code>，就一直循环遍历该链表。快指针每次走两步，慢指针每次走一步。</li>
<li>如果快指针跟慢指针碰上了（<code>slow == fast</code>），那说明链表是有环的，返回<code>true</code>。如果整个链表遍历完了，快慢指针也没碰上，说明无环，返回<code>false</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fastNode != <span class="literal">null</span> &amp;&amp; fastNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fastNode == slowNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、相交链表"><a href="#4、相交链表" class="headerlink" title="4、相交链表"></a>4、相交链表</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
<p>思路：</p>
<ul>
<li>两个链表中，只要有一个是空的（<code>null</code>），则不可能相交，直接返回<code>null</code>。</li>
<li>定义两个当前指针<code>curA</code>和<code>curB</code>，分别指向<code>headA</code>和<code>headB</code>。</li>
<li><code>curA</code>和<code>curB</code>同时向前走，当其中一个指针走到链表的末尾，例如<code>curA==null</code>，此时让<code>curA</code>指向另外一个链表的头结点。（<code>curA.next = headB</code>）。对<code>curB</code>采取同样的操作。之后两个指针继续同步向前走。</li>
<li>当<code>curA</code>和<code>curB</code>相遇时，就是两个链表相交时的结点。返回<code>curA</code>或者<code>curB</code>均可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">            curA = curA != <span class="literal">null</span> ? curA.next : headB;</span><br><span class="line">            curB = curB != <span class="literal">null</span> ? curB.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、移除链表元素"><a href="#5、移除链表元素" class="headerlink" title="5、移除链表元素"></a>5、移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code> ，并让<code>virtualNode.next = head</code>。定义一个当前指针<code>cur</code>指向head头结点。</li>
<li>声明一个前置指针<code>pre</code>，指向<code> virtualNode</code> ，用来临时存储当前指针<code>cur</code>的前一个结点。</li>
<li>使用cur指针遍历当前链表，若当前遍历到的结点的值与指定的value值相同，则删除该结点（<code>pre.next = cur.next</code>），然后<code>cur</code>指针向前走一步，继续完成遍历。否则，继续向前遍历结点，<code>cur</code>与<code>pre</code>指针同时向前走一步。</li>
<li>当<code>cur</code>为<code>null</code>时，说明链表遍历完毕，返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != val) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、反转链表"><a href="#6、反转链表" class="headerlink" title="6、反转链表"></a>6、反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">                由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                      把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、回文链表"><a href="#7、回文链表" class="headerlink" title="7、回文链表"></a>7、回文链表</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
<p>思路：</p>
<ul>
<li>首先使用快慢指针，找到链表的中间结点。假设链表结点个数是K，若K为奇数，则中间结点为K&#x2F;2+1；若K为偶数，则中间结点为K&#x2F;2。（例：K&#x3D;5，那么5&#x2F;2+1&#x3D;3，中间结点是第三个结点）</li>
<li>从中间结点进行断链，左边是前半部分，右边是后半部分。（中间结点属于前半部分！！！）</li>
<li>对原链表的后半部分进行反转。</li>
<li>对原链表的前半部分与原链表后半部分反转之后的链表进行同步遍历，若值不相等，则不是回文链表，反之是回文链表。（由于原链表的后半部分长度一定小于等于前半部分，因此在遍历时，循环结束条件是指向原链表后半部分的指针为<code>null</code>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">endOfFrontHalfPartList</span> <span class="operator">=</span> getEndFrontHalfPartList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedNode</span> <span class="operator">=</span> reverseNode(endOfFrontHalfPartList.next);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> reversedNode;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isHuiWen</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isHuiWen &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                isHuiWen = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isHuiWen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getEndFrontHalfPartList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、链表的中间节点"><a href="#8、链表的中间节点" class="headerlink" title="8、链表的中间节点"></a>8、链表的中间节点</h2><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list">https://leetcode.cn/problems/middle-of-the-linked-list</a></p>
<p>思路：</p>
<ul>
<li>快慢指针。初始时刻，快慢指针均指向头结点。之后快指针每次走两步，慢指针每次走一步。当快指针走到<code>null</code>或者快指针的下一个结点为<code>null</code>了，此时慢指针指向的结点就是链表的中间结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、二进制链表转整数"><a href="#9、二进制链表转整数" class="headerlink" title="9、二进制链表转整数"></a>9、二进制链表转整数</h2><p><a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer">https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer</a></p>
<p>思路：</p>
<ul>
<li>考虑到链表从左向右，指数是递减的。因此进行反转链表。</li>
<li>声明变量<code>k</code>，代表2的指数幂，每遍历一个结点，<code>k++</code>。</li>
<li>声明变量<code>sum</code>用来统计结果。<code>sum = sum += cur.val * Math.pow(2, k)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDecimalValue</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedNode</span> <span class="operator">=</span> reverse(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reversedNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            result += cur.val * Math.pow(<span class="number">2</span>, k);</span><br><span class="line">            k++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、从尾到头打印链表"><a href="#10、从尾到头打印链表" class="headerlink" title="10、从尾到头打印链表"></a>10、从尾到头打印链表</h2><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
<p>思路1：</p>
<p>反转链表+遍历链表打印输出</p>
<p>思路2：</p>
<p>栈是先进后出的，因此可以考虑先将链表中每一个节点入栈，再弹栈。每弹出一个结点，数组存储一个值。栈的实现可以使用LinkedList或者ArrayDeque（推荐：性能好）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、返回链表中倒数第K个节点"><a href="#11、返回链表中倒数第K个节点" class="headerlink" title="11、返回链表中倒数第K个节点"></a>11、返回链表中倒数第K个节点</h2><p>思路：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
<p>快慢指针。快指针先走K步。之后快慢指针同步走，当快指针指向<code>null</code>时，慢指针指向的结点就是倒数第K个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、移除重复节点"><a href="#12、移除重复节点" class="headerlink" title="12、移除重复节点"></a>12、移除重复节点</h2><p><a href="https://leetcode.cn/problems/remove-duplicate-node-lcci">https://leetcode.cn/problems/remove-duplicate-node-lcci</a></p>
<p>思路：</p>
<ul>
<li>HashSet里面存储的元素是不可重复的，因此考虑是用HashSet。</li>
<li>定义一个前驱指针<code>pre</code>，用来记录遍历到的当前结点的前一个结点，以便删除结点时使用。</li>
<li>遍历链表，如果set中不存在，就把结点的值存进set中。</li>
<li>如果set中存在，则删除该结点。<code>pre.next = cur.next</code>。</li>
<li>最后返回头结点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeDuplicateNodes</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(cur.val)) &#123;</span><br><span class="line">                set.add(cur.val);</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><h2 id="1、删除链表倒数第N个节点"><a href="#1、删除链表倒数第N个节点" class="headerlink" title="1、删除链表倒数第N个节点"></a>1、删除链表倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">https://leetcode.cn/problems/remove-nth-node-from-end-of-list</a></p>
<p>思路：</p>
<ul>
<li>因为删除一个结点需要使用到该结点的前一个结点指针。因此，先声明一个虚拟头结点<code>virtualNode</code> ，并定义一个前驱指针<code>pre</code>，让<code>pre</code>指针指向该虚拟头结点。</li>
<li>定义快慢指针<code>slow</code>、<code>fast</code>，快指针<code>fast</code>先走<code>n</code>步，之后<code>pre</code>、<code>slow</code>和<code>fast</code>三个指针同步向前走，当<code>fast</code>为<code>null</code>时，<code>slow</code>所指向的结点即为倒数第N个结点。</li>
<li>有前驱指针<code>pre</code>，即可完成链表的删除操作。<code>pre.next = slow.next</code></li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h2><p><a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code>，并声明一个当前指针<code>cur</code>指向<code>virtualNode</code>。</li>
<li>由于两数相加可能会产生进位，所以定义一个变量<code>jinwei</code>记录进位值。</li>
<li>两数之和除以10，得到十位的值，即进位值（因为两个小于10的数相加，进位要么是0，要么是1）。两数之和对10取余得到个位数（例如：12&#x2F;10&#x3D;1，12%10&#x3D;2。7&#x2F;10&#x3D;0，7%10&#x3D;7）。这里需要注意的是，两数相加之后，还需要加上进位值，且当某一个链表遍历到末尾，即为null时，值指定为0。</li>
<li>当两个链表都遍历结束后，还需要再判断一下是否存在进位值，若存在，则需要再插入一个结点，值为进位值。</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jinwei</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val) +  (l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val) + jinwei;</span><br><span class="line">            jinwei = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jinwei &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(jinwei);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、两两交换链表中的节点"><a href="#3、两两交换链表中的节点" class="headerlink" title="3、两两交换链表中的节点"></a>3、两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头节点<code>virtualNode</code>，并定义一个<code>tmp</code>指针指向<code>virtualNode</code>（需要交换的两个节点中第一个节点的前一个节点）。</li>
<li>每两个节点进行交换，定义一个<code>start</code>指针指向这两个节点中的第一个节点，定义一个<code>end</code>指针指向这两个节点中的第二个节点。初始为：<code>start = tmp.next</code> 和 <code>end = tmp.next.next</code>。</li>
<li>改变指针的指向，使两个节点进行交换。交换完后再让<code>tmp</code>指针指向<code>start</code>即可。（交换之后，start就指向交换过后的两个节点中的后面那个节点，也就是下一组需要交换的两个节点的第一个节点的前一个节点）</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="literal">null</span> &amp;&amp; tmp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> tmp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> tmp.next.next;</span><br><span class="line">            tmp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、旋转链表"><a href="#4、旋转链表" class="headerlink" title="4、旋转链表"></a>4、旋转链表</h2><p><a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></p>
<p>思路：</p>
<ul>
<li>若链表长度为<code>n</code>，则让快指针<code>fast</code>先走<code>k % n</code>步，之后快慢指针一起走。</li>
<li>当<code>fast.next==null</code>时，<code>slow</code>指向的就是新链表的尾结点，<code>slow.next</code>指向的节点就是新的头结点<code>newHead</code>。</li>
<li>所以此时让<code>slow.next==null</code>，进行断链。之后让<code>fast</code>指向<code>head</code>，组成新链表。最后返回<code>newHead</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % num;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        fast.next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、删除链表中的重复元素Ⅱ"><a href="#5、删除链表中的重复元素Ⅱ" class="headerlink" title="5、删除链表中的重复元素Ⅱ"></a>5、删除链表中的重复元素Ⅱ</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii</a></p>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字。返回 已排序的链表。</p>
<p><img src="/img/article_content_img/image-20230425215955324.png" alt="image-20230425215955324"></p>
<p>思路：</p>
<ul>
<li>由于链表是有序的，所以相同的节点肯定是紧挨着的。</li>
<li>由于链表的头节点可能会被删除，因此我们需要额外使用一个虚拟头节点（<code>virtualNode</code>）指向链表的头节点。</li>
<li>定义一个指针<code>cur</code>去遍历链表，初始时，<code>cur</code>指向<code>virtualNode</code>。当<code>cur.next</code>与<code>cur.next.next</code>所指向的元素值相同时，记下这个值为<code>x</code>，之后就需要将<code>cur.next</code>及其后面所有值等于<code>x</code>的节点都删除。当<code>cur.next</code>与<code>cur.next.next</code>所指向的元素值不同时，说明该元素只出现了一次，所以<code>cur = cur.next</code>。</li>
<li>需要注意的是，cur.next有可能是个空节点，因此，判断的时候需要加上<code>cur.next != null</code>。</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、分隔链表"><a href="#6、分隔链表" class="headerlink" title="6、分隔链表"></a>6、分隔链表</h2><p><a href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<p>思路：</p>
<ul>
<li>分别定义两个链表，一个<code>smallList</code>，一个<code>largeList</code>。<code>smallList</code>上节点的值都是小于<code>x</code>的。<code>largeList</code>上节点的值都是大于<code>x</code>的。</li>
<li>定义一个<code>cur</code>指针去遍历给定链表。如果当前节点的值小于<code>x</code>，就往<code>smallList</code>上插入一个新节点。反之，往<code>largeList</code>上插入一个新节点。节点的值都为<code>cur.val</code>。</li>
<li>最后把<code>largeList</code>链接到<code>smallList</code>的后面，并返回<code>smallList</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallCur</span> <span class="operator">=</span> smallList;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeCur</span> <span class="operator">=</span> largeList;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &lt; x) &#123;</span><br><span class="line">                smallCur.next = cur;</span><br><span class="line">                smallCur = smallCur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largeCur.next = cur;</span><br><span class="line">                largeCur = largeCur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        largeCur.next = <span class="literal">null</span>;</span><br><span class="line">        smallCur.next = largeList.next;</span><br><span class="line">        <span class="keyword">return</span> smallList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、反转链表2"><a href="#7、反转链表2" class="headerlink" title="7、反转链表2"></a>7、反转链表2</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>思路：</p>
<ul>
<li>因为可能会存在从第一个结点到某个结点进行反转的情况，因此需要建立一个虚拟头结点<code>virtualNode</code>。</li>
<li>定义一个<code>pre</code>指针，初始在虚拟头结点处，记录需要反转的链表的头结点的前一个结点。</li>
<li>使用快慢指针，<code>fast</code>指针走到right处，<code>slow</code>指针走到left处（<code>pre</code>指针随着<code>slow</code>指针一起走）。定义一个<code>tmpHead</code>指针指向<code>fast</code>的下一个结点。此时，<code>slow</code>到<code>fast</code>这个区间的结点就是需要反转的链表。</li>
<li>断开<code>slow</code>到<code>fast</code>这个区间前后的链接，然后对其进行普通反转链表操作。</li>
<li>反转链表操作得到的是反转之后的头结点，因此<code>pre.next</code>操作将其与之前的链表接上。</li>
<li>声明一个<code>cur</code>指针遍历反转之后的链表，找到最后一个结点，然后与<code>tmpHead</code>接上即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; left) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpHead</span> <span class="operator">=</span> fast.next;</span><br><span class="line">        fast.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedList</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reversedList;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = reversedList;</span><br><span class="line">        cur.next = tmpHead;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、有序链表转换二叉搜索树"><a href="#8、有序链表转换二叉搜索树" class="headerlink" title="8、有序链表转换二叉搜索树"></a>8、有序链表转换二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/</a></p>
<p>思路一：</p>
<ul>
<li>首先初始链表上节点的值是递增的，而且又要保证生成的二叉树是平衡的（对任意一个节点的左右两个子树的高度差不超过1），所以考虑每次从链表的中间节点取值，作为树的根节点。</li>
<li>采用双指针找到链表的中间节点，之后就创建一个新节点，值为中间节点的值。之后递归地去找当前中间节点左边那一部分的中间节点（生成左子树），递归地去找当前节点右边那一部分的中间节点（生成右子树）。</li>
<li>最后返回生成的二叉树的根节点即可。</li>
<li>双指针找中间节点：<ol>
<li>定义快指针<code>fast</code>与慢指针<code>slow</code>，以及前驱指针<code>pre</code>。</li>
<li><code>fast</code>指针每次走两步，<code>slow</code>与<code>pre</code>指针每次走一步。</li>
<li>当<code>fast == null</code>或者<code>fast.next == null</code>时，此时<code>slow</code>指针所指的位置就是中间节点的位置。</li>
<li>让<code>pre.next = null</code>进行断链，此时，<code>head</code>到<code>pre</code>就是中间节点的前半部分，<code>slow.next</code>到末尾就是中间节点的后半部分。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(slow.val);</span><br><span class="line">        node.left = sortedListToBST(head);</span><br><span class="line">        node.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<ul>
<li>使用一个List集合先将链表上节点的值存储起来。</li>
<li>然后找中间节点使用二分法，即<code>mid = left + (right - left) / 2</code>。后续步骤与思路一类似。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertToBST(list, <span class="number">0</span>, list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertToBST</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(list.get(mid));</span><br><span class="line">        root.left = convertToBST(list, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = convertToBST(list, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、将二叉树展开为链表"><a href="#9、将二叉树展开为链表" class="headerlink" title="9、将二叉树展开为链表"></a>9、将二叉树展开为链表</h2><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list</a></p>
<p>思路：</p>
<p><img src="/img/article_content_img/image-20230425181116678.png" alt="image-20230425181116678"></p>
<p>其实是分为三步：</p>
<ul>
<li>首先将根节点的左子树变成链表</li>
<li>其次将根节点的右子树变成链表</li>
<li>最后将变成链表的右子树放在变成链表的左子树的最右边</li>
</ul>
<p>这就是一个递归的过程，递归的一个非常重要的点就是：<strong>不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出。</strong>对于函数flatten来说：</p>
<ul>
<li>函数作用：将一个二叉树，原地将它展开为链表</li>
<li>输入：树的根节点</li>
<li>输出：无</li>
</ul>
<p>那我们就直接根据三步来写程序就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将根节点的左子树变成链表</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        <span class="comment">//将根节点的右子树变成链表</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        <span class="comment">//因为需要将左子树拼到根节点的右边，所以先使用temp临时存储一下右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="comment">//把树的右边换成左边的链表</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        <span class="comment">//记得要将左边置空</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//找到树的最右边的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">null</span>) root = root.right;</span><br><span class="line">        <span class="comment">//把右边的链表接到刚才树的最右边的节点</span></span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、复制带随机指针的链表"><a href="#10、复制带随机指针的链表" class="headerlink" title="10、复制带随机指针的链表"></a>10、复制带随机指针的链表</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
<p>思路：</p>
<p><img src="/img/article_content_img/image-20230425191755847.png" alt="image-20230425191755847"></p>
<ul>
<li>使用HashMap，key为原节点，value是复制的新节点（创建的新节点）</li>
<li>共有两次对原链表的遍历。第一次遍历，创建新节点，并将原节点与新节点存入HashMap中。第二次遍历，添加新节点之间的指针指向关系。</li>
</ul>
<p><img src="/img/article_content_img/image-20230425191931161.png" alt="image-20230425191931161"></p>
<ul>
<li>从图中可以看出原节点和新节点是一一对应的关系，<code>newNode</code>为新结点，<code>cur</code>为原结点，则：<ul>
<li><code>newNode = map.get(cur)</code></li>
<li><code>newNode.next = map.get(cur.next)</code></li>
<li><code>newNode.random = map.get(cur.random)</code></li>
</ul>
</li>
<li>最后返回新结点的头结点，即<code>map.get(head)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            map.put(cur, newNode);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> map.get(cur);</span><br><span class="line">            <span class="comment">// 如果cur有next，才复制</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                newNode.next = map.get(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果cur有random，才复制</span></span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="literal">null</span>) &#123;</span><br><span class="line">                newNode.random = map.get(cur.random);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、环形链表2"><a href="#11、环形链表2" class="headerlink" title="11、环形链表2"></a>11、环形链表2</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<p>返回第一个入环节点，若无环，返回null。</p>
<p>思路：</p>
<ul>
<li>快慢指针：快指针每次走两步，慢指针每次走一步。</li>
<li>当慢指针跟快指针第一次碰面时，让快指针重新指向头节点。</li>
<li>之后快指针与慢指针每次均走一步。若第二次碰面，则碰面时的那个节点就是入环节点。</li>
<li>需要注意的是，因为在第一次碰面前，快指针走的比慢指针快，所以如果链表是无环的，那么快指针一定会先走到<code>null</code>处，或者快指针的下一个节点是<code>null</code>。那么此时直接返回<code>null</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意此处！！！！</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、重排链表"><a href="#12、重排链表" class="headerlink" title="12、重排链表"></a>12、重排链表</h2><p><a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a></p>
<p>1 –&gt; 2 –&gt; 3- -&gt; 4 –&gt; 5 –&gt; 6      &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&gt;  1 –&gt; 6 –&gt; 2 –&gt; 5 –&gt; 3 –&gt; 4</p>
<p>1 –&gt; 2 –&gt; 3     &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&gt;  1 –&gt; 3 –&gt; 2 </p>
<p>思路：</p>
<ul>
<li>通过快慢指针找到中间节点，然后断链。</li>
<li>对后面的链表进行反转。</li>
<li>将前面的链表与反转之后的链表进行拼接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(tmpNode);</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> newHead.next;</span><br><span class="line">            newHead.next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            head = newHead.next;</span><br><span class="line">            newHead = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13、LRU缓存"><a href="#13、LRU缓存" class="headerlink" title="13、LRU缓存"></a>13、LRU缓存</h2><p><a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
<p>思路：理解的背下来就行。很简单！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span> <span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNodeToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addNodeToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addNodeToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(res.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、对链表进行插入排序"><a href="#14、对链表进行插入排序" class="headerlink" title="14、对链表进行插入排序"></a>14、对链表进行插入排序</h2><p><a href="https://leetcode.cn/problems/insertion-sort-list/">https://leetcode.cn/problems/insertion-sort-list/</a></p>
<p>思路：</p>
<p>+ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastOrderNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> lastOrderNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastOrderNode.val &lt;= cur.val) &#123;</span><br><span class="line">                lastOrderNode = lastOrderNode.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">                <span class="keyword">while</span> (pre.next.val &lt; cur.val) &#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                lastOrderNode.next = cur.next;</span><br><span class="line">                cur.next = pre.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = lastOrderNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、排序链表"><a href="#15、排序链表" class="headerlink" title="15、排序链表"></a>15、排序链表</h2><p><a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<p>思路：</p>
<ul>
<li>分割cut环节：找到当前链表中点，并从中点将链表断开（以便在下次递归cut时，链表片段拥有正确边界）<ul>
<li>我们使用<code>fast</code>，<code>slow</code>快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li>
<li>找到中点<code>slow</code>后，执行<code>slow.next = null</code>将链表切断。</li>
<li>递归分割时，输入当前链表左端点<code>head</code>和中心节点<code>slow</code>的下一个节点<code>tmp</code>（因为链表是从<code>slow</code>切断的）。</li>
<li>cut递归终止条件：当<code>head.next == null</code>时，说明只有一个节点了，直接返回此节点。</li>
</ul>
</li>
<li>合并 merge 环节：将两个排序链表合并，转化为一个排序链表。<ul>
<li>双指针法合并，建立辅助<code>ListNode h</code>作为头部。</li>
<li>设置两指针<code>left</code>，<code>right</code>分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助<code>ListNode h</code>作为头部的下个节点<code>h.next</code>。</li>
<li>时间复杂度<code>O(l + r)</code>，<code>l</code>，<code>r</code> 分别代表两个链表长度。</li>
</ul>
</li>
<li>当题目输入的<code>head == null</code>时，直接返回<code>null</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(tmp);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、奇偶链表"><a href="#16、奇偶链表" class="headerlink" title="16、奇偶链表"></a>16、奇偶链表</h2><p><a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></p>
<p>思路：</p>
<ul>
<li>第一个节点是奇数结点，第二个节点是偶数节点，以此类推。</li>
<li>将原链表拆分成两个链表，即一个奇数链表，一个偶数链表。</li>
<li>因为head可以作为奇数链表的头节点，而且head也是最终结果链表的头节点，因此只需要定义一个偶数链表的头节点（<code>evenHead</code>），初始化为<code>head</code>的下一个节点。（因为<code>head</code>的下一个节点一定是偶数节点）</li>
<li>声明一个奇数链表遍历指针<code>oddCur</code>和偶数链表遍历指针<code>evenCur</code>。</li>
<li>因为偶数链表遍历指针在前，所以要保证<code>evenCur != null</code> &amp;&amp; <code>evenCur.next != null</code>。</li>
<li>然后断链重连，将奇数节点与奇数节点连接，偶数节点与偶数节点连接。</li>
<li>最后将奇数链表的尾与偶数链表的头接上，并返回结果链表的头节点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> evenHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17、合并零之间的节点"><a href="#17、合并零之间的节点" class="headerlink" title="17、合并零之间的节点"></a>17、合并零之间的节点</h2><p><a href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">https://leetcode.cn/problems/merge-nodes-in-between-zeros/</a></p>
<p>思路：</p>
<ul>
<li>由于链表的开端和结尾都是0，所以可以直接跳过，从第二个节点开始遍历。因此遍历指针<code>cur=head.next</code>。</li>
<li>用一个变量<code>sum</code>记录两个0之间的节点的值之和。</li>
<li>遍历节点，如果节点的值不为0，则累加到<code>sum</code>中。如果为0，则再新的链表上插入一个新节点，节点的值为<code>sum</code>。之后将<code>sum</code>清零，然后跳过该节点，继续遍历下一个节点。</li>
<li>最后返回新链表即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeNodes</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += cur.val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h1><h2 id="1、实现LFU缓存"><a href="#1、实现LFU缓存" class="headerlink" title="1、实现LFU缓存"></a>1、实现LFU缓存</h2><p><a href="https://leetcode.cn/problems/lfu-cache/">https://leetcode.cn/problems/lfu-cache/</a></p>
<p>思路：理解的背下来就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wyd.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wyd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/05/24/20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  LFU缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表的前继Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表的后继Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node post;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList doublyLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表表示的频次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的前继链表（pre.freq &lt;-- this.freq）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的后继链表 (post.freq --&gt; this.freq)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList post;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的头节点，新节点从头部加入，表示最近访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的尾节点，删除节点从尾部删除，表示最久访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">(<span class="type">int</span> freq)</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="built_in">this</span>.freq = freq;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.pre.post = node.post;</span><br><span class="line">        node.post.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.post = head.post;</span><br><span class="line">        head.post.pre = node;</span><br><span class="line">        head.post = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.doublyLinkedList = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LfuCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储缓存的内容。</span></span><br><span class="line"><span class="comment">     * Node中包括key、value、freq、所在doublyLinkedList、所在doublyLinkedList中的nextNode、所在doublyLinkedList中的preNode。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer, Node&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * firstLinkedList.post 是频次最大的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList firstLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lastLinkedList.pre 是频次最小的双向链表，满了之后删除 lastLinkedList.pre.tail.pre 这个Node即为频次最小且访问最早的Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList lastLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LfuCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line"></span><br><span class="line">        firstLinkedList = <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        lastLinkedList = <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        firstLinkedList.post = lastLinkedList;</span><br><span class="line"></span><br><span class="line">        lastLinkedList.pre = firstLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该key访问频次+1</span></span><br><span class="line"></span><br><span class="line">        freqInc(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若key存在，则更新value，访问频次+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">            freqInc(node);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若key不存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果缓存满了，删除lastLinkedList.pre这个链表（即表示最小频次的链表）中的tail.pre这个Node（即最小频次链表中最先访问的Node），如果该链表中的元素删空了，则删掉该链表。</span></span><br><span class="line"></span><br><span class="line">                cache.remove(lastLinkedList.pre.tail.pre.key);</span><br><span class="line"></span><br><span class="line">                lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);</span><br><span class="line"></span><br><span class="line">                size--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) &#123;</span><br><span class="line"></span><br><span class="line">                    removeDoublyLinkedList(lastLinkedList.pre);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cache中put新Key-Node对儿，并将新node加入表示freq为1的DoublyLinkedList中，若不存在freq为1的DoublyLinkedList则新建。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastLinkedList.pre.freq != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">DoublyLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>(<span class="number">1</span>);</span><br><span class="line">                addDoublyLinkedList(newDoublyLinedList, lastLinkedList.pre);</span><br><span class="line">                newDoublyLinedList.addNode(newNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastLinkedList.pre.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * node的访问频次 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">freqInc</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node从原freq对应的双向链表里移除, 如果链表空了则删除链表。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DoublyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> node.doublyLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="type">DoublyLinkedList</span> <span class="variable">preLinkedList</span> <span class="operator">=</span> linkedList.pre;</span><br><span class="line"></span><br><span class="line">        linkedList.removeNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (linkedList.head.post == linkedList.tail) &#123;</span><br><span class="line"></span><br><span class="line">            removeDoublyLinkedList(linkedList);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node加入新freq对应的双向链表，若该链表不存在，则先创建该链表。</span></span><br><span class="line"></span><br><span class="line">        node.freq++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLinkedList.freq != node.freq) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">DoublyLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>(node.freq);</span><br><span class="line"></span><br><span class="line">            addDoublyLinkedList(newDoublyLinedList, preLinkedList);</span><br><span class="line"></span><br><span class="line">            newDoublyLinedList.addNode(node);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            preLinkedList.addNode(node);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addDoublyLinkedList</span><span class="params">(DoublyLinkedList newDoublyLinedList, DoublyLinkedList preLinkedList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.post = preLinkedList.post;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.post.pre = newDoublyLinedList;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.pre = preLinkedList;</span><br><span class="line"></span><br><span class="line">        preLinkedList.post = newDoublyLinedList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeDoublyLinkedList</span><span class="params">(DoublyLinkedList doublyLinkedList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        doublyLinkedList.pre.post = doublyLinkedList.post;</span><br><span class="line"></span><br><span class="line">        doublyLinkedList.post.pre = doublyLinkedList.pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、合并K个升序链表"><a href="#2、合并K个升序链表" class="headerlink" title="2、合并K个升序链表"></a>2、合并K个升序链表</h2><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
<p>思路：</p>
<p>+ </p>
<h2 id="3、K个一组翻转链表"><a href="#3、K个一组翻转链表" class="headerlink" title="3、K个一组翻转链表"></a>3、K个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">https://leetcode.cn/problems/reverse-nodes-in-k-group</a></p>
<p>思路：</p>
<ul>
<li>由于第一个节点也是需要翻转的，所以需要先创建一个虚拟头节点<code>virtualNode</code>，<code>virtualNode.next=head</code>。</li>
<li>之后要确定翻转链表的范围，且需要记录翻转部分的头节点的前驱结点以及翻转部分的尾结点的后继节点。因此定义一个<code>pre</code>指针，该指针指向需要翻转的链表的头节点的前驱结点。定义一个<code>end</code>指针指向需要翻转的链表的尾结点。那么<code>end.next</code>就是需要翻转的链表的尾节点的后继节点。初始时，<code>pre</code>、<code>end</code>均指向<code>virtualNode</code>，相当于初始时，<code>pre</code>、<code>end</code>都先指向需要翻转的链表的头节点的前驱结点。</li>
<li>由于K个一组翻转，所以需要先将<code>end</code>移动到一组当中的第K个节点处。即<code>end</code>先走K步。这里需要注意的是，<code>end</code>不能为<code>null</code>。如果<code>end</code>为<code>null</code>，说明剩余链表长度无法达到K个，则不用翻转了。</li>
<li>当<code>end</code>走到指定位置后，定义一个<code>start</code>指针指向需要翻转的链表的头节点，即<code>pre.next</code>。定义一个<code>next</code>指针指向需要翻转的链表的尾节点的后继节点，即<code>end.next</code>。</li>
<li>然后让<code>pre.next=null</code>，<code>end.next=null</code>，进行断链，然后进行翻转链表操作。</li>
<li>之后让<code>pre.next</code>指向翻转之后的链表的头节点。即<code>pre.next = reverse(start)</code>。因此这里可以进行简写，把上面的<code>pre.next = null</code>去掉。由于翻转之前<code>start</code>指向头节点，那么翻转之后就指向尾节点了，所以让<code>start.next = next</code>，将其与后面的链表进行重连。</li>
<li>然后更新<code>pre</code>、<code>end</code>指针的位置，使其重新指向需要进行翻转的链表的头节点的前驱节点，准备进行下一次翻转操作。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/866b404c6b0b52fa02385e301ee907fc015742c3766c80c02e24ef3a8613e5ad-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> virtualNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特殊情况，反转部分长度不足k时，定位完成end后，end会为null。</span></span><br><span class="line">            <span class="comment">// 所以要判断一下，如果为null了，直接跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题汇总（二）</title>
    <url>/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、TCP与UDP的区别"><a href="#一、TCP与UDP的区别" class="headerlink" title="一、TCP与UDP的区别"></a>一、TCP与UDP的区别</h1><ul>
<li><strong>是否面向连接：</strong>TCP是面向连接的，即传输数据之前，需要先与服务端通过“三次握手”建立连接，数据传输完成后，通过“四次挥手”释放连接。而UDP则是无连接的，可以直接进行数据的传输。</li>
<li><strong>传输是否可靠：</strong>TCP由于具有“三次握手”、“四次挥手”、流量控制、拥塞控制、超时重传、确认等机制，保证了TCP的传输是可靠的，即无差错、不丢失、不重复、按序到达。而UDP不具有上述机制，因此传输是不可靠的。</li>
<li><strong>是否具有状态：</strong>TCP传输是有状态的，即TCP会去记录自己发送消息的状态。比如：消息是否发送了、消息是否被接收了等。因此，TCP会维持一个复杂的连接状态表。而UDP传输是无状态的。</li>
<li><strong>首部开销：</strong>TCP的首部开销为20个字节，UDP的首部开销8个字节。</li>
<li><strong>传输形式：</strong>TCP是基于字节流进行传输，而UDP是基于报文进行传输。</li>
<li><strong>传输效率：</strong>由于TCP具有各种各样的机制来保证其传输的可靠性，因此传输效率比UDP低很多。</li>
<li><strong>是否支持广播或多播服务：</strong>TCP只支持一对一（点对点）通信，而UDP既支持一对一通信，也支持一对多、多对一、多对多通信。</li>
<li><strong>应用场景：</strong>TCP主要用于严格保证数据可靠传输的场景，例如：文件、邮件传输。而UDP主要用于追求实时性，即便丢失一些数据也无关紧要的场景，例如：直播、语音、视频、游戏等。</li>
</ul>
<h1 id="二、TCP和UDP首部的格式"><a href="#二、TCP和UDP首部的格式" class="headerlink" title="二、TCP和UDP首部的格式"></a>二、TCP和UDP首部的格式</h1><p>UDP首部由源端口号、目标端口号、包长度、校验和组成。</p>
<ul>
<li><strong>源端口号（Source Port）：</strong>表示发送端端口号，字段长16位（2字节）。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候，该字段的值设置为0。</li>
<li><strong>目标端口号（Destination Port）：</strong>表示接收端端口号，字段长16位（2字节）。</li>
<li><strong>包长度（Length）：</strong>该字段保存了UDP首部的长度与数据的长度之和，单位为字节。</li>
<li><strong>校验和（Checksum）：</strong>校验和是为了提供可靠的UDP首部和数据而设计的。包括校验和字段在内的所有数据之和结果为“16位全部为1”时，才会被认为所收到的数据是正确的。</li>
</ul>
<blockquote>
<p>关于UDP首部校验和具体的计算逻辑，可以参考《图解TCP&#x2F;IP（第5版）》220页。</p>
</blockquote>
<p>TCP首部由源端口号、目标端口号、序列号、确认应答号、数据偏移、保留、控制位、窗口大小、校验和、紧急指针、选项、填充构成。</p>
<ul>
<li><p><strong>源端口号（Source Port）：</strong>表示发送端端口号，字段长16位（2字节）。</p>
</li>
<li><p><strong>目标端口号（Destination Port）：</strong>表示接收端端口号，字段长度16位（2字节）。</p>
</li>
<li><p><strong>序列号（Sequence Number）：</strong>指发送数据的位置，序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。每发送一次数据，就累加一次该数据字节数的大小。字段长32位（4字节）。</p>
</li>
<li><p><strong>确认应答号（Acknowledgement Number）：</strong>指下一次应该收到的数据的序列号，字段长度32位（4字节）。实际上，可以将其理解为发送端收到这个确认应答以后，可以认为在这个序号以前的数据都已经被正确接收。</p>
</li>
<li><p><strong>数据偏移（Data Offset）：</strong>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。字段长4位，单位为4字节。</p>
</li>
<li><p><strong>保留（Reserved）：</strong>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即时收到的包中该字段不为0，此包也不会被丢弃。</p>
</li>
<li><p><strong>控制位（Control Flag）：</strong>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫作控制位。当他们对应位上的值为1时，具有不同的含义。例如：CWR标志和ECE标志都用于IP首部的ECN字段，ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<blockquote>
<p>关于控制位值为1时具体的含义，可以参考《图解TCP&#x2F;IP（第5版）》223页。</p>
</blockquote>
</li>
<li><p><strong>窗口大小（Window Size）：</strong>用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小，该字段长16位（2字节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小，但这个探测数据必须是1字节。</p>
</li>
<li><p><strong>校验和（Checksum）：</strong>与UDP类似，区别在于TCP的校验和无法关闭。</p>
<blockquote>
<p>关于TCP首部校验和具体的计算逻辑，可以参考《图解TCP&#x2F;IP（第5版）》224页。</p>
</blockquote>
</li>
<li><p><strong>紧急指针（Urgent Pointer）：</strong>该字段长16位（2字节）。只有在URG控制位为1时有效。该字段表示本报文段中紧急数据的指针，即从数据部分的首位到紧急指针所指示的位置为紧急数据。</p>
</li>
<li><p><strong>选项（Options）：</strong>该字段用于提高TCP的传输性能。长度最大为40字节。</p>
<blockquote>
<p>关于每个选项字段具体的含义，可以参考《图解TCP&#x2F;IP（第5版）》225页。</p>
</blockquote>
</li>
</ul>
<h1 id="三、HTTP是基于TCP还是UDP的？"><a href="#三、HTTP是基于TCP还是UDP的？" class="headerlink" title="三、HTTP是基于TCP还是UDP的？"></a>三、HTTP是基于TCP还是UDP的？</h1><p>HTTP&#x2F;3.0之前是基于TCP协议的，而HTTP&#x2F;3.0弃用TCP，改用基于UDP的QUIC协议。主要目的是解决HTTP&#x2F;2.0中存在的队头阻塞问题。由于HTTP&#x2F;2.0在单个TCP连接上使用了多路复用技术，受到TCP拥塞控制的影响，少量的丢包就可能导致整个TCP连接上的所有流被阻塞。此外，HTTP&#x2F;2.0需要经过“三次握手”的过程建立连接，一般是3个RTT（往返时延），而借助QUIC协议的特性，HTTP&#x2F;3.0可以避免TCP的“三次握手”的延迟，允许在第一次连接时发送数据（0个RTT）。</p>
<h1 id="四、TCP的三次握手"><a href="#四、TCP的三次握手" class="headerlink" title="四、TCP的三次握手"></a>四、TCP的三次握手</h1><p><img src="/img/article_content_img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p><strong>第一次握手：</strong>客户端将自己的SYN设置为1，并随机生成一个客户端的初始序列号（Sequence Number）发送给服务端，然后客户端进入<em>SYN_SENT</em>状态。</p>
<p><strong>第二次握手：</strong>服务端收到客户端发来的SYN&#x3D;1之后，就知道客户端此时想要建立连接了。此时，服务端将自己的SYN与ACK都设置为1，并生成一个确认应答号（Acknowledgement Number），确认应答号的值为客户端传过来的初始序列号的值加一，即Acknowledgement Number &#x3D; Sequence Number + 1。之后随机生成一个服务端的初始序列号（Sequence Number），将SYN、ACK、Acknowledgement Number、Sequence Number一并发送给客户端，然后服务端进入<em>SYN_RECV</em>状态。</p>
<p><strong>第三次握手：</strong>客户端收到服务端发回的信息后，验证Acknowledgement Number是否为自己的初始序列号的值加一，验证通过后，客户端将自己的ACK设置为1，并生成一个确认应答号（Acknowledgement Number），该值等于服务端传过来的初始序列号的值加一，然后将ACK与Acknowledgement Number发送给服务端，此时客户端进入<em>Establish</em>状态。服务端收到客户端传过来的信息后，验证Acknowledgement Number是否为自己的初始序列号的值加一，若验证通过，则服务端也进入<em>Establish</em>状态。</p>
<p>自此，连接建立完成，“三次握手”结束。</p>
<h1 id="五、为什么TCP连接是三次握手，而不是两次或者四次？"><a href="#五、为什么TCP连接是三次握手，而不是两次或者四次？" class="headerlink" title="五、为什么TCP连接是三次握手，而不是两次或者四次？"></a>五、为什么TCP连接是三次握手，而不是两次或者四次？</h1><p><strong>结论：TCP连接允许“四次握手”，不允许“两次握手”。</strong></p>
<p>“三次握手”的目的是建立可靠的通信信道，要确认自己与对方的发送与接收都是正常的。</p>
<ol>
<li><strong>第一次握手：</strong>Client什么都没有确认。Server确认了自己的接收和Client的发送正常。</li>
<li><strong>第二次握手：</strong>Client确认了自己的发送和接收、Server的发送和接收正常。Server确认了自己的发送正常。</li>
<li><strong>第三次握手：</strong>Server确认了Client的接收正常。</li>
</ol>
<p><strong>而两次握手会导致的问题主要有以下两个：</strong></p>
<ul>
<li><p>如果是两次握手，那么当服务端发送SYN、ACK、Acknowledge Number、Sequence Number之后，连接就建立完成。但由于客户端没有给服务端返回ACK和Acknowledge Number，服务端就不知道客户端是否收到了发送过去的东西，即服务端无法确认自己的发送和对方的接收是正常的。</p>
</li>
<li><p>客户端发出的第一个连接请求没有丢失，只是在某个网络节点长时间滞留了，而客户端没有收到任何反馈，则再次发起连接请求，此时，连接正常建立。当此次连接断开时，之前滞留的请求发送到了服务端，那么服务端会给客户端发送SYN、ACK、Acknowledge Number、Sequence Number。</p>
<p>如果采用的是“两次握手”，到此连接就已经建立完成，但此时客户端并没有想要建立连接，所以客户端就不会理会服务端，但服务端却一直在等待客户端发送数据，因此服务端的资源就被白白浪费了。</p>
<p>如果采用的是“三次握手”，当服务端给客户端发送SYN、ACK、Acknowledge Number、Sequence Number后，客户端依旧不会给服务端任何回应，此时服务端会重发上述信息，默认发送5次，如果发送5次之后仍没有收到客户端的任何回应，则服务端会进入CLOSED状态，避免了服务端资源的浪费。</p>
</li>
</ul>
<p><strong>四次握手：</strong>将第二次握手分成两步。</p>
<ul>
<li><p><strong>第一步：</strong>服务端发送ACK和Acknowledge Number到客户端。</p>
</li>
<li><p><strong>第二步：</strong>服务端发送SYN和Sequence Number到客户端。</p>
<p>出于优化的目的，提高效率，将这两步合并。</p>
</li>
</ul>
<h1 id="六、第三次握手中，如果客户端的ACK未送达服务端，客户端与服务端分别会做出什么处理。"><a href="#六、第三次握手中，如果客户端的ACK未送达服务端，客户端与服务端分别会做出什么处理。" class="headerlink" title="六、第三次握手中，如果客户端的ACK未送达服务端，客户端与服务端分别会做出什么处理。"></a>六、第三次握手中，如果客户端的ACK未送达服务端，客户端与服务端分别会做出什么处理。</h1><p><strong>服务端：</strong></p>
<ul>
<li>如果客户端发出的ACK未及时送达服务端，那么服务端会重发SYN、ACK、Acknowledge Number、Sequence Number，默认发送5次，如果发送5次之后仍没有收到客户端的任何回应，则服务端会进入CLOSED状态。</li>
</ul>
<blockquote>
<p>重传次数：由内核参数<code>top_syn_retries</code>配置，默认值为5，可以手动修改。</p>
<p>重传周期：按照“指数退避”算法计算重传周期，即第一次是1秒后进行超时重传，第二次是2秒后进行超时重传，第三次是4秒后进行超时重传，第四次是8秒后进行超时重传，第五次是16秒后进行超时重传，以类类推，直到达到最大重传次数。</p>
</blockquote>
<p><strong>客户端：</strong></p>
<ul>
<li><p>服务端还未进入CLOSED状态：</p>
<p>在服务端超时重发的过程中，客户端及时向服务端发送ACK并且该ACK抵达服务端，那么服务端收到之后进行ACK和Acknowledge Number的验证，验证通过则进入ESTABLISH状态，连接建立。</p>
</li>
<li><p>服务端已进入CLOSED状态：</p>
<p>客户端依旧向服务端发送数据，但由于服务端已经进入CLOSED状态，此时服务端会给客户端回应一个RST包。</p>
</li>
</ul>
<h1 id="七、如果连接已经建立，但客户端出现了故障怎么办？"><a href="#七、如果连接已经建立，但客户端出现了故障怎么办？" class="headerlink" title="七、如果连接已经建立，但客户端出现了故障怎么办？"></a>七、如果连接已经建立，但客户端出现了故障怎么办？</h1><p>服务端每收到一个客户端的发来的请求，会对该请求建立一个计时器，这个计时器通常设置为2小时。如果2小时后，仍未收到客户端的任何数据，此时服务端会发送一个探测报文段到客户端，一共会发送10次，每隔75秒发送一次，如果发送10次都没有反应的话，服务端会认为客户端出现了故障，连接就会关闭。</p>
<h1 id="八、TCP三次握手中，哪一次握手最容易受到攻击？"><a href="#八、TCP三次握手中，哪一次握手最容易受到攻击？" class="headerlink" title="八、TCP三次握手中，哪一次握手最容易受到攻击？"></a>八、TCP三次握手中，哪一次握手最容易受到攻击？</h1><p>在TCP三次握手中，<strong>第二次握手</strong>最容易受到攻击，即SYN洪水攻击。具体原因如下：</p>
<p>如果客户端伪造出大量第一次的SYN同步报文，服务端就会依次消耗掉很多资源来保存客户端的信息，并进行确认，实际上确认是会失败的，但失败需要一定的时间，因为服务端会连续多次进行第二次握手确认后才认定失败。那么短时间有大量的SYN同步报文涌向服务端，服务端资源可能被耗尽，就可能导致正常的客户端得不到响应而失败。</p>
<p>解决措施：</p>
<ul>
<li><p><strong>缩短SYN超时时间，限制同时打开的SYN半连接数目。</strong></p>
<p>SYN Flood攻击效果取决于服务端保持的SYN半连接数目，该值等于SYN攻击的频度乘上SYN超时时间。设置SYN超时时间在20秒以下可以成倍降低服务器的负荷。</p>
</li>
<li><p><strong>设置SYN Cookie</strong></p>
<p>当服务端接收到SYN包并返回SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值，并将这个cookie值作为将要返回的SYN + ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则认为是一个正常连接，之后分配资源并建立连接；如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包都会被丢弃。</p>
</li>
<li><p><strong>防火墙</strong></p>
</li>
</ul>
<h1 id="九、TCP的四次挥手"><a href="#九、TCP的四次挥手" class="headerlink" title="九、TCP的四次挥手"></a>九、TCP的四次挥手</h1><p><img src="/img/article_content_img/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p>
<p><strong>第一次挥手：</strong>客户端将自己的FIN设置为1，并随机生成一个客户端的初始序列号（Sequence Number），发送给服务端，请求断开客户端到服务端之间的通信。此时，客户端进入<em>FIN_WAIT_1</em>状态。</p>
<p><strong>第二次挥手：</strong>服务端收到客户端的FIN后，将自己的ACK设置为1，并生成一个确认应答号（Acknowledgement Number），确认应答号的值为客户端传过来的初始序列号的值加一，即Acknowledgement Number &#x3D; Sequence Number + 1。之后将ACK与确认应答号发送到客户端，服务端进入<em>CLOSE_WAIT</em>状态。客户端收到并验证ACK与确认应答号，验证通过后，进入<em>FIN_WAIT_2</em>状态。</p>
<p><strong>第三次挥手：</strong>服务端将自己的FIN设置为1，并随机生成一个服务端的初始序列号（Sequence Number），发送给客户端，请求断开服务端到客户端之间的通信。此时，服务端进入<em>LAST_ACK</em>状态。</p>
<p><strong>第四次挥手：</strong>客户端收到服务端的FIN后，将自己的ACK设置为1，并生成一个确认应答号，该值为服务端传过来的初始序列号的值加一。之后将ACK与确认应答号发送到服务端，客户端进入<em>TIME_WAIT</em>状态。服务端收到并验证ACK与确认应答号，验证通过，进入<em>CLOSED</em>状态。客户端在等待2MSL的时间后，也进入<em>CLOSED</em>状态。</p>
<p>自此，连接断开完成，“四次挥手”结束。</p>
<p>&#x3D;&#x3D;注意：只要四次挥手没有结束，客户端和服务端就可以继续传输数据！&#x3D;&#x3D;</p>
<blockquote>
<p><strong>MSL（Maximum Segment Lifetime）</strong>：一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。</p>
</blockquote>
<h1 id="十、为什么要四次挥手？"><a href="#十、为什么要四次挥手？" class="headerlink" title="十、为什么要四次挥手？"></a>十、为什么要四次挥手？</h1><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放的通知，对方确认后再完全断开TCP连接。</p>
<h1 id="十一、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？（CLOSE-WAIT状态的意义）"><a href="#十一、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？（CLOSE-WAIT状态的意义）" class="headerlink" title="十一、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？（CLOSE_WAIT状态的意义）"></a>十一、为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？（CLOSE_WAIT状态的意义）</h1><p>因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发送完，因此先给客户端传回 ACK，表示已经接收到了断开连接的请求。等到数据发完之后再向客户端发送 FIN，申请断开服务端到客户端的数据传送。</p>
<h1 id="十二、为什么第四次挥手时，客户端需要等待2MSL后才进入CLOSED状态？"><a href="#十二、为什么第四次挥手时，客户端需要等待2MSL后才进入CLOSED状态？" class="headerlink" title="十二、为什么第四次挥手时，客户端需要等待2MSL后才进入CLOSED状态？"></a>十二、为什么第四次挥手时，客户端需要等待2MSL后才进入CLOSED状态？</h1><p>第四次挥手时，客户端发送到服务端的ACK和确认应答号有可能丢失，如果服务端因为某些原因而没有收到ACK和确认应答号的话，服务端会重发FIN和初始序列号。</p>
<p>如果客户端在2MSL的时间内收到了FIN和初始序列号，就会重新发送ACK和确认应答号，并再次等待2MSL。</p>
<p>如果客户端没有等待2MSL的时间，而是直接进入CLOSED状态，那么客户端将永远无法收到服务端重发的FIN，而服务端因为一直未收到客户端的ACK和确认应答号，会不停的重发FIN，连接始终无法断开。</p>
<h1 id="十三、第二次挥手时，如果服务端的ACK没有送达客户端，会怎么样？"><a href="#十三、第二次挥手时，如果服务端的ACK没有送达客户端，会怎么样？" class="headerlink" title="十三、第二次挥手时，如果服务端的ACK没有送达客户端，会怎么样？"></a>十三、第二次挥手时，如果服务端的ACK没有送达客户端，会怎么样？</h1><p>如果第二次挥手时，服务端ACK和确认应答号没有送达客户端，那么客户端会认为可能是第一次挥手时发送的FIN未送达服务端，因此客户端会重新发送FIN和初始序列号。</p>
<h1 id="十四、TIME-WAIT状态的意义"><a href="#十四、TIME-WAIT状态的意义" class="headerlink" title="十四、TIME_WAIT状态的意义"></a>十四、TIME_WAIT状态的意义</h1><p>首先，&#x3D;&#x3D;TIME_WAIT并不属于客户端或服务端专属的状态，而是属于主动发起断开连接请求的一端的状态&#x3D;&#x3D;，在发送最后一次ACK和确认应答号后会进入TIME_WAIT状态。</p>
<p>这里假设是客户端发起的断开连接的请求，客户端在第四次挥手发送ACK和确认应答号之后，可能由于网络比较阻塞，该数据帧在传输过程中丢失了，服务端由于没有收到ACK则会重发FIN，但此时如果客户端没有TIME_WAIT状态，而是直接进入CLOSED状态，则客户端不会理会服务端，服务端就会一直重发FIN。</p>
<p>因此，采用TIME_WAIT状态用来保障当网络比较阻塞时，TCP连接依旧可以正常关闭。</p>
<h1 id="十五、TIME-WAIT状态过多会产生什么后果？怎么处理？"><a href="#十五、TIME-WAIT状态过多会产生什么后果？怎么处理？" class="headerlink" title="十五、TIME_WAIT状态过多会产生什么后果？怎么处理？"></a>十五、TIME_WAIT状态过多会产生什么后果？怎么处理？</h1><p>从服务端来讲，短时间内主动关闭了大量的客户端连接，就会造成服务端上出现大量的TIME_WAIT状态，严重消耗服务端的资源，此时部分客户端就会显示连接不上。</p>
<p>从客户端来讲，客户端TIME_WAIT过多会导致端口资源被占用，而端口就65535个，一旦被占满就无法创建新的连接。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>服务端可以设置<code>SO_REUSEADDR</code>套接字选项来避免TIME_WAIT状态，此套接字选项告诉内核：即时此端口正忙（处于TIME_WAIT），也请继续并重用它。</p>
</li>
<li><p>调整系统内核参数，修改<code>/etc/sysctl.conf</code>文件中<code>net.ipv4.tcp_tw_reuse</code>和<code>tcp_timestamps</code>参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1 # 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 # 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十六、TCP如何保证可靠传输？"><a href="#十六、TCP如何保证可靠传输？" class="headerlink" title="十六、TCP如何保证可靠传输？"></a>十六、TCP如何保证可靠传输？</h1><ol>
<li><strong>基于数据块传输：</strong>应用数据被分割成TCP认为最适合发送的数据块，再传输给网络层。数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重：</strong>TCP为了保证不发生丢包，发送端会对数据包进行编号，接收端会对收到的包进行排序，并对编号重复的包进行去重。</li>
<li><strong>校验和：</strong>TCP将保持它首部和数据的校验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果检验和有差错，那么TCP将丢弃这个报文段并且不会对此报文段进行确认。</li>
<li><strong>超时重传：</strong>当发送方发送数据后，它启动一个定时器，等待接收端确认收到这个报文段。若在规定时间内仍为收到确认，则重传该报文段。</li>
<li><strong>流量控制：</strong>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据时，能提示发送方降低发送速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>拥塞控制：</strong>当网络出现拥塞时，减少数据的发送。（慢启动、拥塞避免、快重传、快恢复）</li>
<li><strong>ARQ协议（自动重传请求）</strong>：连续ARQ协议与停止等待ARQ协议。</li>
</ol>
<h1 id="十七、TCP流量控制是如何实现的？"><a href="#十七、TCP流量控制是如何实现的？" class="headerlink" title="十七、TCP流量控制是如何实现的？"></a>十七、TCP流量控制是如何实现的？</h1><p><strong>首先考虑一个问题，为什么要引入流量控制？</strong></p>
<p>双方在通信的时候，发送方的速率跟接收方的速率不一定相等，那如果发送方的发送速率过快，接收方速率慢导致来不及接收，这个时候接收方就会把来不及接收的数据包放到缓存区中。那如果接收方缓存区满了，此时发送方还在不停的发送数据，就会导致丢包的情况。大量丢包会浪费服务器资源。因此，需要控制发送方的发送速率，让发送方跟接收方形成动态平衡的状态。</p>
<p><img src="/img/article_content_img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89.png" alt="流量控制（一）"></p>
<p><strong>怎么去进行流量控制？</strong></p>
<p>使用滑动窗口协议来进行流量控制。</p>
<p><img src="/img/article_content_img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89.png" alt="流量控制（二）"></p>
<p>从图中可以看出，窗口大小目前设定为7，灰色的部分是已经发送并且收到了返回的ACK的数据包。黄色的部分是已经发送但还没有收到ACK的数据包。绿色的部分是准备发送的数据包。后面11-16是还没有被读进内存的数据，所以他们也不在滑动窗口内。</p>
<p><strong>接下来分两种情况来讨论：</strong></p>
<ul>
<li><strong>正常情况：</strong></li>
</ul>
<p><img src="/img/article_content_img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%89%EF%BC%89.png" alt="流量控制（三）"></p>
<p>从图中我们可以看出，4号数据包已经发送并收到返回的ACK，此时窗口可以右移，但是一定要保证窗口大小还是7。因此，现在11号数据包被读进了窗口中（缓存区），成为了待发送的状态。8号和9号数据包变成黄色，说明已经发送出去了，但是还没有收到返回的ACK。重复上述操作，直到所有的数据都发送成功。</p>
<ul>
<li><strong>丢包情况：</strong></li>
</ul>
<p><img src="/img/article_content_img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E5%9B%9B%EF%BC%89.png" alt="流量控制（四）"></p>
<p>如果数据已经发送出去了，但是接收方返回的ACK没有及时送达，可能丢失了，又或者数据看似发出去了，但是接收方根本没收到，那此时发送方会一直等待接收ACK，而接收方也一直在等待发送方继续发送数据，但是因为发送方在没收到返回的ACK之前是不能将窗口右移的，所以就会陷入一种僵局，即死锁状态。</p>
<p><strong>那应该怎么去解决这种问题呢？</strong></p>
<p>采用<strong>超时重传机制</strong>。因为接收方在返回的ACK中是包含着接收窗口的大小的。如果发送方在发送出数据之后始终收不到返回的ACK，会启用一个持续计时器，当计时器到时后，会主动的向接收方去发送1个字节的探测数据包，查看接收窗口的状态。如果这时候检测到接收窗口的大小是大于0的，那发送方会重发刚才的数据包，如果接收窗口大小等于0，那就刷新这个计时器，重复上述操作，这样就不会产生僵局的情况了。</p>
<p><img src="/img/article_content_img/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%94%EF%BC%89.png" alt="流量控制（五）"></p>
<h1 id="十八、接收窗口大小是固定的吗？接收窗口是否越大越好？"><a href="#十八、接收窗口大小是固定的吗？接收窗口是否越大越好？" class="headerlink" title="十八、接收窗口大小是固定的吗？接收窗口是否越大越好？"></a>十八、接收窗口大小是固定的吗？接收窗口是否越大越好？</h1><p><strong>TCP发送窗口可以划分为四个部分：</strong></p>
<ol>
<li><p>已经发送并且确认的TCP段（已经发送并确认）</p>
</li>
<li><p>已经发送但还没有确认的TCP段（已经发送未确认）</p>
</li>
<li><p>未发送但接收方准备接收的TCP段（可以发送）</p>
</li>
<li><p>未发送并且接收方也不准备接收的TCP段（不可发送）</p>
</li>
</ol>
<p><strong>TCP发送窗口结构示意图：</strong></p>
<p><img src="/img/article_content_img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E4%B8%80%EF%BC%89.jpg" alt="滑动窗口（一）"></p>
<ul>
<li>SND.WND：发送窗口</li>
<li>SND.UNA：Send Unacknowledged指针，指向发送窗口的第一个字节。</li>
<li>SND.NXT：Send Next指针，指向可用窗口的第一个字节。</li>
</ul>
<p><strong>可用窗口大小：</strong><code>SND.UNA + SND.WND - SND.NXT</code></p>
<p><strong>TCP接收窗口可以划分成三个部分：</strong></p>
<ol>
<li>已经接收并且确认的TCP段（已经接收并确认）</li>
<li>等待接收并且允许发送方发送的TCP段（可以接收未确认）</li>
<li>不可接收并且不允许发送方发送的TCP段（不可接收）</li>
</ol>
<p><strong>TCP接收窗口结构示意图：</strong></p>
<p><img src="/img/article_content_img/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E4%BA%8C%EF%BC%89.jpg" alt="滑动窗口（二）"></p>
<p>接收窗口的大小是根据网络环境以及发送方的拥塞窗口大小动态调整的。</p>
<p>接收窗口如果太小，会严重浪费链路利用率，增加丢包率。如果接收窗口太大，不仅不会减少丢包率，反而会增加内存消耗。</p>
<h1 id="十九、零窗口"><a href="#十九、零窗口" class="headerlink" title="十九、零窗口"></a>十九、零窗口</h1><p>接收方没有能力接收数据的时候，会把接收窗口大小设置为0，此时发送方需要暂停发送数据，但是会启动一个持续计时器，计时器到时后，发送方会发送一个字节的探测数据包，查看接收窗口的状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据的发送。</p>
<h1 id="二十、拥塞控制"><a href="#二十、拥塞控制" class="headerlink" title="二十、拥塞控制"></a>二十、拥塞控制</h1><p>关于拥塞控制的详细介绍，可以点击下面的链接进行查看。</p>
<p><a href="http://love2peace.top/2023/06/24/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/">TCP的拥塞控制是如何实现的？</a></p>
<h1 id="二十一、ARQ协议是什么？"><a href="#二十一、ARQ协议是什么？" class="headerlink" title="二十一、ARQ协议是什么？"></a>二十一、ARQ协议是什么？</h1><p><strong>自动重传请求（Automic Repeat-reQuest， ARQ）</strong>：是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间内没有收到确认信息，即ACK，它通常会重新发送，直到收到确认或者达到重试次数。</p>
<p>ARQ协议包括<strong>停止等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p>
<h2 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h2><p>停止等待ARQ协议是为了实现可靠传输的，它的基本原理就是每发送完一个分组后就停止发送，等待对方确认（回复ACK）。如果达到设置的超时时间后，还是没有收到ACK，说明没有发送成功，需要重新发送，直到收到确认后再发送下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但仍需要对发送方返回确认ACK。</p>
<ol>
<li><p><strong>无差错情况：</strong></p>
<p>发送方发送分组，接收方在规定时间内收到，并回复ACK，发送方再次发送。</p>
</li>
<li><p><strong>有差错情况：（超时重传）</strong></p>
<p>停止等待协议中超时重传是指：只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此，每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。此外，在停止等待协议中，若收到重复分组，就丢弃该分组，但同时还要发送确认ACK。</p>
</li>
<li><p><strong>确认丢失和确认迟到：</strong></p>
<ul>
<li><strong>确认丢失：</strong>确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1的确认消息，但却在传输过程中丢失。而A并不知道，在超时计时器超时后，A重传M1消息，B再次收到该消息后采取以下两点措施：<ul>
<li>丢弃这个重复的M1消息，不向上层交付。 </li>
<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ul>
</li>
<li><strong>确认迟到：</strong>确认消息在传输过程中迟到。当A发送M1消息，B收到并发送确认。在超时时间内A没有收到确认消息，因此A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息，A接着发送其他数据了。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：<ul>
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong>简单。</p>
<p><strong>缺点：</strong>信道利用率低、等待时间长。</p>
<h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p>连续ARQ协议可以提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫Go-Back-N（回退N），表示需要退回来重传已经发送过的 N 个消息。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题汇总（三）</title>
    <url>/2023/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、介绍一下RIP协议"><a href="#一、介绍一下RIP协议" class="headerlink" title="一、介绍一下RIP协议"></a>一、介绍一下RIP协议</h1><p><strong>RIP（Routing Information Protocol，路由信息协议）：</strong>每一个路由器维护一张表，记录该路由器到其他网络节点的跳数。路由器与其直接相连的网络节点的跳数为1，每经过一个网络节点跳数加一。跳数最大为15，超过15则认为不可达。</p>
<p>更新表的时候，和相邻路由器交换路由信息。交付数据时，优先选取距离最短的路径。</p>
<h1 id="二、TCP黏包"><a href="#二、TCP黏包" class="headerlink" title="二、TCP黏包"></a>二、TCP黏包</h1><p>TCP粘包指发送方发送的若干个包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p>
<p><strong>造成TCP粘包的原因：</strong></p>
<ul>
<li>TCP默认使用nagle算法，该算法做两件事：<ol>
<li>只有上一个分组得到确认，才会发送下一个分组。</li>
<li>收到多个小分组，在最后小分组的确认到来时一起发送。</li>
</ol>
</li>
<li>接收方将收到的数据保存在接收缓存中，然后应用程序主动从缓存读取收到的分组。如果从TCP接收数据包到存入缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<p><strong>什么时候需要处理粘包对象？</strong></p>
<ul>
<li><p>如果发送方发送的多组数据本来就是同一块数据的不同部分，不需要处理。</p>
</li>
<li><p>若多个分组毫不相干，就需要处理。</p>
</li>
</ul>
<p><strong>如何处理TCP粘包现象？</strong></p>
<ul>
<li><p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决。</p>
</li>
<li><p>接收方没有办法处理粘包对象，只能将问题交给应用层来处理。</p>
</li>
<li><p>应用层：循环处理，应用程序从接收缓存中读取分组时，读完一条数据就应该循环读取下一条数据，直到所有数据都被处理完成。</p>
</li>
</ul>
<p>1）格式化数据，增加结束标识。2）在数据之前添加发送长度。</p>
<h1 id="三、重定向和转发的区别？"><a href="#三、重定向和转发的区别？" class="headerlink" title="三、重定向和转发的区别？"></a>三、重定向和转发的区别？</h1><p><strong>重定向：</strong>地址栏发生变化，是两次请求，可以访问其他服务器的资源。</p>
<p><strong>转发：</strong>地址栏路径不变，是一次请求，只能访问当前服务器下的资源。</p>
<h1 id="四、CSRF攻击"><a href="#四、CSRF攻击" class="headerlink" title="四、CSRF攻击"></a>四、CSRF攻击</h1><p>CSRF是跨站请求伪造，攻击者盗用了用户的身份，以用户的名义发送恶意请求。</p>
<p><strong>CSRF需要满足两个步骤：</strong></p>
<ol>
<li>用户登录受信任的网站A，并在本地生成Cookie</li>
<li>在不登出网站A的情况下，访问危险网站B</li>
</ol>
<p><strong>解决方式：</strong></p>
<ol>
<li>在客户端页面增加伪随机数。</li>
<li>验证码。每次用户提交都要在表单中填写验证码。</li>
<li>不使用Cookie进行Session验证，而使用HTTP请求参数传递Session ID或Token可以抵御CSRF攻击。</li>
</ol>
<h1 id="五、什么是子网掩码？"><a href="#五、什么是子网掩码？" class="headerlink" title="五、什么是子网掩码？"></a>五、什么是子网掩码？</h1><p>子网掩码是指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位是主机的位掩码。子网掩码不能单独存在，必须与IP地址一起使用。</p>
<p>子网掩码只有一个作用，就是用于屏蔽IP地址的一部分以区分网络标识和主机标识，并说明该IP是在局域网还是广域网上。</p>
<h1 id="六、什么是网关？"><a href="#六、什么是网关？" class="headerlink" title="六、什么是网关？"></a>六、什么是网关？</h1><p>网关又称网间连接器、协议转换器，网关在网络层以上实现网关互联。</p>
<h1 id="七、什么是WebSocket协议？"><a href="#七、什么是WebSocket协议？" class="headerlink" title="七、什么是WebSocket协议？"></a>七、什么是WebSocket协议？</h1><p>服务器可以主动向客户端推送消息，客户端也可以向服务器发送消息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<h1 id="八、ARP协议"><a href="#八、ARP协议" class="headerlink" title="八、ARP协议"></a>八、ARP协议</h1><p>ARP，地址解析协议。</p>
<ul>
<li>主机A运行ARP，在本局域网上广播发送一个ARP请求分组。内容是我的IP是xxx，硬件地址是xxx，想要知道IP地址为xxx的硬件地址（MAC地址）。</li>
<li>假设B的IP地址与A要查询的一致，就收下这个ARP分组，并向A发送响应分组，写入自己的硬件地址。内容是我的IP是xxx，硬件地址是xxx。</li>
</ul>
<h1 id="九、DNS域名解析使用哪个传输层协议？为什么？"><a href="#九、DNS域名解析使用哪个传输层协议？为什么？" class="headerlink" title="九、DNS域名解析使用哪个传输层协议？为什么？"></a>九、DNS域名解析使用哪个传输层协议？为什么？</h1><p>两种都使用。DNS在进行区域传输的时候使用TCP协议，其他时候使用UDP协议。</p>
<p><strong>DNS在进行区域传输的时候使用TCP协议，是因为：</strong></p>
<ul>
<li>数据同步传送的数据量比一个请求和应答的数据量要多的多</li>
<li>TCP是一种可靠的连接，保证了数据的准确性</li>
</ul>
<p><strong>其他时候使用UDP协议，是因为：</strong></p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。</li>
</ul>
<h1 id="十、DNS解析全过程"><a href="#十、DNS解析全过程" class="headerlink" title="十、DNS解析全过程"></a>十、DNS解析全过程</h1><p>当一个用户在地址栏输入网址时，DNS解析有大致十个过程：</p>
<ol>
<li>浏览器先检查自身缓存中有没有被解析过的这个域名对应的IP地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。</li>
<li>如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在Windows中可通过C盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的IP地址，那浏览器会首先使用这个IP地址。</li>
<li>如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</li>
<li>如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析。</li>
<li>根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址。</li>
<li>此时LDNS再发送请求给上一步返回的gTLD。</li>
<li>接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器。</li>
<li>Name Server根据映射关系表找到目标IP，返回给LDNS。</li>
<li>LDNS缓存这个域名和对应的IP。</li>
<li>LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试题汇总（一）</title>
    <url>/2023/06/26/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="介绍一下MySQL的特点"><a href="#介绍一下MySQL的特点" class="headerlink" title="介绍一下MySQL的特点"></a>介绍一下MySQL的特点</h1><ol>
<li>MySQL功能完善、性能卓越、服务稳定，很少出现异常宕机。</li>
<li>MySQL开源免费且没有版权制约，自主性及使用成本低。</li>
<li>MySQL历史悠久，用户活跃度高，遇到问题可以去社区寻求帮助。</li>
<li>MySQL体积小，安装方便，易于维护。</li>
<li>MySQL支持多种操作系统，提供多种API接口，支持多种开发语言。</li>
<li>MySQL事务支持优秀，支持分库分表、读写分离和高可用。</li>
</ol>
<h1 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h1><p>关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系，包括：一对一、一对多、多对多。</p>
<p>关系型数据库中，数据都被存放在了各种表中，表中的每一行就存放着一条数据。</p>
<p><img src="/img/article_content_img/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93.jpg" alt="关系型数据库"></p>
<p><strong>常见的关系型数据库：</strong>MySQL、Oracle、SQL Server、SQLite、PostgreSQL…</p>
<h1 id="MySQL存储引擎有哪些？架构了解吗？"><a href="#MySQL存储引擎有哪些？架构了解吗？" class="headerlink" title="MySQL存储引擎有哪些？架构了解吗？"></a>MySQL存储引擎有哪些？架构了解吗？</h1><p>MySQL支持多种存储引擎，我们可以通过<code>SHOW ENGINES;</code>命令来查看，具体如下图：</p>
<p><img src="/img/article_content_img/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg"></p>
<p>从上图可以看出，MySQL支持9种存储引擎，默认使用InnoDB存储引擎，也只有InnoDB存储引擎支持事务。</p>
<blockquote>
<p>MySQL5.5 之前的版本，默认存储疫情是MyISAM，从MySQL5.5之后才默认采用InnoDB存储引擎。</p>
<p>你可以通过<code>SELECT VERSION();</code>命令查看MySQL的版本。</p>
</blockquote>
<p>MySQL存储引擎采用的是<strong>插件式架构</strong>，支持多种存储引擎，甚至可以针对不同的业务场景，给每张表设置不同的存储引擎。<strong>存储引擎是基于表的，而不是基于数据库的！</strong></p>
<h1 id="MyISAM存储引擎和InnoDB存储引擎有哪些区别？"><a href="#MyISAM存储引擎和InnoDB存储引擎有哪些区别？" class="headerlink" title="MyISAM存储引擎和InnoDB存储引擎有哪些区别？"></a>MyISAM存储引擎和InnoDB存储引擎有哪些区别？</h1><ol>
<li>InnoDB是事务性存储引擎，因此支持事务操作，而MyISAM不支持事务。</li>
<li>InnoDB支持外键，而MyISAM不支持。</li>
<li>InnoDB既支持行级锁，也支持表级锁，默认采用行级锁。而MyISAM仅支持表级锁。</li>
<li>基于InnoDB的表必须有主键，如果未主动设置主键列，则InnoDB会检索表中是否具有唯一索引，如果有唯一索引，那么会把加了唯一索引的列指定为主键列，否则，InnoDB会自动生成一个6Byte的自增主键。而MyISAM允许没有主键。</li>
<li>MySQL5.7版本之前，InnoDB是不支持全文索引的，5.7版本之后才支持。而MyISAM引擎一直支持全文索引。</li>
<li>InnoDB支持MVCC（多版本并发控制），而MyISAM不支持。</li>
<li>InnoDB不保存表的具体行数，因此在执行 <code>select count(*) from table</code> 时需要进行全表扫描，相当于扫描整个磁盘。而MyISAM使用一个变量保存了整个表的行数，执行上述命令时，直接读出该变量的值即可，速度相对较快。</li>
<li>MyISAM和InnoDB底层数据结构都是B+树，但是具体实现方式有所不同。基于InnoDB引擎的表只有一个.ibd文件，这个.ibd文件既存放索引，也存放数据，即每一个非叶子节点存放索引，叶子节点存放索引以及索引对应的数据。而基于MyISAM引擎的表具有.myi和.myd两个文件，.myi文件存储表中索引以及索引对应数据的指针，即每一个非叶子节点存放索引，叶子节点存放索引以及索引对应数据的指针，该指针就指向.myd文件中存放的数据。</li>
</ol>
<h1 id="InnoDB为什么推荐使用自增ID作为主键"><a href="#InnoDB为什么推荐使用自增ID作为主键" class="headerlink" title="InnoDB为什么推荐使用自增ID作为主键"></a>InnoDB为什么推荐使用自增ID作为主键</h1><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用B+树索引模型，所以数据都是存放在B+树的叶子节点中的。</p>
<p><strong>每一个索引在InnoDB里面都对应一颗B+树。</strong>因此，一张表其实就是由多个B+树构成的，即一个主键索引树和多个非主键索引树。</p>
<p>现在假设我们有一个主键列为ID的表，表中有一个字段k，并且字段k上加了索引。建表SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k)) engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>表中R1-R5的（ID,k）值分别为（100,1）、（200,2）、（300,3）、（500,5）和（600,6），具体如下图所示：</p>
<p><img src="/img/article_content_img/mysql1.jpg" alt="InnoDB索引组织结构"></p>
<p>从图中可以看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<blockquote>
<p>主键索引的叶子节点保存的整行数据，而非主键索引的叶子节点保存的是主键的值。例如：查询k&#x3D;3的数据，则先在非主索引树中找到对应主键的值为300，再进行回表，去主键索引树中查找ID为300的数据。</p>
</blockquote>
<p><strong>索引维护：</strong></p>
<p>B+树为了维护<strong>索引有序性</strong>，在插入新值的时候需要做必要的维护。以上图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。但如果新插入的ID值为400，则需要逻辑上挪动后面的数据，以腾出位置。</p>
<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时需要申请一个新的数据页，然后挪动部分数据过去，这个过程称之为页分裂，而页分裂会影响性能。此外，原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p><strong>自增ID作为主键，功能上来说，我们在插入数据时无需指定ID值，系统会根据当前ID最大值加1作为下一条记录的ID值。因此，这种插入数据的模式，非常符合递增插入的场景，每次插入一条新记录都是追加操作，不会涉及挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不能保证有序插入，这样就有可能导致频繁的页分裂和合并，写数据成本相对较高，影响性能。</strong></p>
<p><strong>此外，从存储的角度来说，由于每个非主键索引的叶子节点上都是主键的值，那么如果主键长度太长，非主键索引的叶子节点就越大，占用的空间也就越大。</strong>例如：使用<code>VARCHAR</code>类型的唯一字段身份证号作为主键，则每个非主键索引的叶子节点占用约20个字节，如果使用整型（<code>INT</code>）数据做主键，则只需要4个字节，如果是长整型（<code>BIGINT</code>）则需要8个字节。</p>
<blockquote>
<p><code>VARCHAR</code>需要使用1个或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255个字节，则只使用1个字节表示，否则使用2个字节。假设采用<code>latin-1</code>字符集，一个<code>VARCHAR(10)</code>的列需要11个字节的存储空间。<code>VARCHAR(1000)</code>的列则需要1002个字节。</p>
</blockquote>
<p>因此，综合考虑性能和存储两方面，自增ID作为主键都会是更合理的选择！</p>
<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><p>事务就是逻辑上的一组操作，要么全部执行成功，要么全部执行失败。事务以<code>BEGIN/START TRANSACTION</code>开始，以<code>ROLLBACK/COMMIT</code>结束。</p>
<p>事务具有四大特性：A（原子性）、C（一致性）、I（隔离性）、D（持久性）。</p>
<ul>
<li><p><strong>原子性（Atomicity）：</strong>指事务是最小的执行单位，不允许分割。事务中的操作要么全部执行成功，要么全部执行失败。</p>
</li>
<li><p><strong>一致性（Consistency）：</strong>指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。合法的数据状态就是要满足预定的约束，这个约束可以自己来定义。满足这个约束，数据就是一致的，否则就是不一致的。</p>
<p>例子：</p>
<ul>
<li>规定如下约束：账户余额必须大于等于0。A账户有200元，转账300元出去，那么A账户余额变为-100元。此时，数据就是不一致的，因为不满足账户余额必须大于等于0这一约束。</li>
<li>规定如下约束：A账户与B账户余额之和必须相同。A账户有200元，B账户有100元，A+B&#x3D;300元。A转账50元给B账户，A账户的钱已经扣了，但是B账户因为各种意外原因，余额并未增加，那么A+B&#x3D;250元。此时，数据就是不一致的，因为不满足A账户与B账户余额之和必须相同的约束。</li>
</ul>
</li>
<li><p><strong>隔离性（Isolation）：</strong>指事务与事务之间不能互相干扰，即并发访问数据库的时候，一个用户的事务不能被其他事务所干扰，各并发事务之间数据库是独立的。</p>
</li>
<li><p><strong>持久性（Durability）：</strong>指事务一旦提交，它对数据库的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响。</p>
</li>
</ul>
<p><strong>注：原子性、隔离性和持久性是数据库保证一致性的手段，一致性是最终要达到的目的！也就是说，只有保证了原子性、隔离性和持久性，才能保证一致性！</strong></p>
<h1 id="数据库如何保证原子性？"><a href="#数据库如何保证原子性？" class="headerlink" title="数据库如何保证原子性？"></a>数据库如何保证原子性？</h1><p>利用<strong>回滚日志（undo log）</strong>来实现原子性。所有事务执行期间所做的操作的<strong>逆操作</strong>都会被记录到undo log中，如果事务执行过程中遇到异常，出现了回滚，则可以直接利用undo log进行数据恢复，恢复到事务执行之前的状态。此外，undo log会先于数据持久化到磁盘上，这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询undo log来回滚之前未完成的事务。</p>
<blockquote>
<p><strong>逆操作：</strong></p>
<ul>
<li>当插入（INSERT）一条数据的时候，undo log中会记录这条数据对应的删除（DELETE）记录。</li>
<li>当删除（DELETE）一条数据的时候，undo log中会记录这条数据对应的插入（INSERT）记录。</li>
<li>当更新（UPDATE）一条数据（新值）的时候，undo log中会记录这条数据（旧值）对应的（UPDATE）记录。</li>
</ul>
</blockquote>
<h1 id="数据库如何保证持久性？"><a href="#数据库如何保证持久性？" class="headerlink" title="数据库如何保证持久性？"></a>数据库如何保证持久性？</h1><p>利用重做日志（redo log）来实现持久性。</p>
<p>MySQL是先把磁盘上的数据加载到内存，在内存中对数据进行修改，再写回到磁盘上。如果此时出现宕机，内存中的数据就会丢失。而redo log解决了这个问题，当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘（redo log一部分在内存中，一部分在磁盘上）。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定是回滚数据还是提交数据。</p>
<p>此外，采用redo log具有以下好处：</p>
<ul>
<li>redo log体积小，毕竟只记录了哪一页修改了什么，所以刷盘快。</li>
<li>redo log是一直往末尾追加，属于顺序IO，效率显然比随机IO高。</li>
</ul>
<h1 id="数据库如何保证隔离性？"><a href="#数据库如何保证隔离性？" class="headerlink" title="数据库如何保证隔离性？"></a>数据库如何保证隔离性？</h1><p>我们首先需要知道，如果无法保证隔离性会出现哪些问题呢？</p>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务，所以可能会导致以下问题的出现：</p>
<h2 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h2><p>简单来说，脏读是指一个事务读取了被另一个事务修改但未提交的数据。</p>
<p>一个事务读取数据并对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时，另外一个事务读取了这个还未提交的数据，但第一个事务由于一些原因进行了回滚，导致数据并没有提交到数据库，那么第二个事务读取到的就是脏数据，即产生了脏读。</p>
<p>下面将举一个例子来更为直观地说明脏读。</p>
<p>例：事务1读取某表中的数据A&#x3D;20，之后事务1修改数据A&#x3D;A-1&#x3D;19，但还未提交。这时，事务2读取表中数据A&#x3D;19，然后事务1进行回滚导致对数据A的修改并未提交到数据库，A的值还是20。所以事务2读取到的就是脏数据。</p>
<p><img src="/img/article_content_img/%E8%84%8F%E8%AF%BB.png" alt="脏读"></p>
<h2 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h2><p>简单来说，就是一个事务修改了的数据，被另外一个事务再次修改，导致第一个事务修改的数据被覆盖（丢失）了。</p>
<p>一个事务读取一个数据时，另外一个事务也读取了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。此时，第一个事务内的修改结果就被丢失了，因此称为丢失修改。</p>
<p>下面将举一个例子来更为直观地说明丢失修改。</p>
<p>例：事务1读取某表中的数据A&#x3D;20，事务2也读取了该表中的数据A&#x3D;20，然后事务1先修改了数据A&#x3D;A-1&#x3D;19，然后提交到数据库，后来事务2也修改了这个数据A&#x3D;A-1&#x3D;19，并提交到数据库。最终A的值为19。但是A进行了两次减1操作，A的值应该是18才对。这就是丢失修改，即事务1修改的数据A的值被事务2修改的数据A的值覆盖（丢失）了。</p>
<p><img src="/img/article_content_img/%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png" alt="丢失修改"></p>
<h2 id="不可重复读（Unrepeatable-Read）"><a href="#不可重复读（Unrepeatable-Read）" class="headerlink" title="不可重复读（Unrepeatable Read）"></a>不可重复读（Unrepeatable Read）</h2><p>简单来说，就是一个事务在执行期间，多次读取同一个数据，得到的值不一致。</p>
<p>一个事务读取一个数据时，另外一个事务也读取了该数据，并对该数据进行了修改。此时，第一个事务再次读取该数据时，发现与之前读取的值不一样了，这就是不可重复读。</p>
<p>下面将举一个例子来更为直观地说明不可重复读。</p>
<p>例：事务1读取某表中的数据A&#x3D;20，事务2也读取了该表中的数据A&#x3D;20并将A的值进行了修改A&#x3D;A-1&#x3D;19，此时事务1再次读取数据A的值&#x3D;19，这与第一次读取A的值&#x3D;20不同。</p>
<p><img src="/img/article_content_img/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="不可重复读"></p>
<h2 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h2><p>简单来说，就是一个事务在执行期间，多次读取同样的几行数据，但相比于第一次读取，会新增一些数据，就像出现了幻觉一样。</p>
<p>一个事务读取了几行数据，接着另外一个并发事务往表中插入了一些新数据，之后第一个事务再次读取这几行数据时，发现数据变多了（不该出现的数据），这就是幻读。</p>
<p>下面将举一个例子来更为直观地说明不可重复读。</p>
<p>事务1根据条件（where name like “%王”）查询了某表中的一批数据（假设有5条数据），接着并发事务2往表中插入了一行数据，该数据同样满足上述条件，此时事务1再次根据该条件查询数据时，发现有6条数据，相比于之前多了一条。</p>
<p><img src="/img/article_content_img/%E5%B9%BB%E8%AF%BB.png" alt="幻读"></p>
<h2 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="不可重复读和幻读有什么区别？"></a>不可重复读和幻读有什么区别？</h2><ul>
<li>不可重复读主要针对的是<strong>某一行</strong>数据，并且针对的是<strong>UPDATE</strong>操作。</li>
<li>幻读主要针对的是一个<strong>数据整体&#x2F;范围</strong>，并且针对的是<strong>INSERT</strong>操作。</li>
</ul>
<p>因此，我们只要防止上述问题出现，即可保证事务的隔离性。那么如何防止上述问题出现呢？这里就需要隔离级别的概念。</p>
<h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><p>SQL标准定义了四个隔离级别，其级别从低到高依次是：读未提交、读已提交、不可重复读、串行化。</p>
<ul>
<li><strong>读未提交（READ UNCOMMITTED）：</strong>允许读取尚<strong>未提交</strong>的数据变更，即一个事务提交之前，其执行结果对其他事务是可见的。该隔离级别最低，会导致脏读、不可重复读和幻读。</li>
<li><strong>读已提交（READ COMMITTED）：</strong>允许读取并发事务<strong>已经提交</strong>的数据，即一个事务只能读取已经提交了的事务对数据做出的变更。该隔离级别是<strong>Oracle的默认隔离级别</strong>，可以解决脏读，但无法解决不可重复读和幻读。</li>
<li><strong>可重复读（REPEATABLE READ）：</strong>确保同一个事务在执行期间，多次读取相同数据时，得到的结果相同。该隔离级别是<strong>MySQL的默认隔离级别</strong>，可以解决脏读和不可重复读，但无法解决幻读。</li>
<li><strong>串行化（SERIALIZABLE）：</strong>所有事务串行执行，保证事务之间完全不可能产生干扰。该隔离级别最高，可以解决脏读、不可重复读和幻读问题，但是性能非常低，可能会导致大量的超时和锁竞争现象。一般不会使用。</li>
</ul>
<h1 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h1><p>锁是一种常见的并发事务的控制方式。根据加锁的范围，MySQL中的锁大致可以分为：全局锁、表锁和行锁。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，可以通过<code>FLUSH TABLES WITH READ LOCK</code>（FTWRL）命令实现。加锁后，整个库处于只读状态，之后其他线程的数据更新语句（增、删、改）、数据定义语句（建表、修改表结构等）和更新类事务的提交语句，均会被阻塞。</p>
<p><strong>全局锁的典型使用场景：全库逻辑备份</strong></p>
<p>但备份过程中，整个库完全处于<strong>只读</strong>状态，也会造成以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间，主库不能执行更新，业务基本停摆。</li>
<li>如果在从库备份，那么备份期间从库无法执行主库同步过来的binlog，导致主从数据不一致。</li>
</ul>
<p>当然，官方自带的逻辑备份工具是<strong>mysqldump</strong>，当mysqldump使用参数<code>-single-transaction</code>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。但此方法只适用于所有的表使用事物引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过全局锁这种方式来实现了。</p>
<p><strong>那么既然要做全库只读，为什么不使用<code>set global readonly = true</code>的方式呢？</strong></p>
<p>主要有以下两个原因：</p>
<ul>
<li>某些系统中，<code>readonly</code>的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改global变量的方式影响面更大，不建议使用。</li>
<li>在异常处理机制上存在差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库可以回到正常更新的状态。而将整个库设置为readonly后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写的状态，风险较高。</li>
</ul>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁是MySQL中锁定粒度仅次于全局锁的一种锁，是<strong>针对非索引字段</strong>加的锁，对当前操作的整张表加锁，<strong>实现简单，资源消耗少，加锁快，不会出现死锁，但触发锁冲突的概率最高，高并发下效率低</strong>。表级锁与存储引擎无关，MyISAM和InnoDB引擎都支持表级锁。</p>
<p><strong>MySQL中表级锁有两种：表锁、元数据锁（MDL，Meta Data Lock ）</strong></p>
<h3 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h3><p>表锁的加锁语法为<code>lock tables xxx read/write</code>，<code>xxx</code>为表名，<code>read/write</code>为读锁或写锁。解锁可以使用<code>unlock tables</code>命令主动释放锁，也可以在客户端断开的时候自动释放。</p>
<p>在表级锁中，如果加的是读锁，则当前线程读、写操作和其他线程的读操作均可以进行，但其他线程的写操作会被阻塞。如果加的是写锁，则当前线程的读、写操作均可进行，但其他线程的读、写操作均被阻塞。</p>
<h3 id="元数据锁（MDL，Meta-Data-Lock）"><a href="#元数据锁（MDL，Meta-Data-Lock）" class="headerlink" title="元数据锁（MDL，Meta Data Lock）"></a>元数据锁（MDL，Meta Data Lock）</h3><p>MDL在MySQL5.5之后引入，该锁不需要显式使用，当访问一个表的时候会被自动加上。<strong>MDL的作用是保证读写的正确性，即用于隔离DML和DDL操作之间的干扰。</strong>例如：如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构就对不上了，肯定是有问题的。</p>
<p>当对一个表做增、删、改、查操作时，需要加MDL读锁，当对一个表做结构变更时，需要加MDL写锁。</p>
<ul>
<li>读锁之间不互斥，允许多个线程对同一张表进行增、删、改、查操作。</li>
<li>读锁与写锁之间，写锁与写锁之间互斥，所以如果有两个线程同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p><strong>使用MDL锁中遇到的问题：</strong>给小表加字段导致数据库挂掉。（事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交之后再释放）</p>
<p><img src="/img/article_content_img/MDL%E9%94%81%E9%97%AE%E9%A2%98.jpg" alt="MDL锁问题"></p>
<p>从上图可以看出，sessionA先启动，这时候对表<code>t</code>加一个MDL读锁。由于sessionB需要的也是MDL读锁，因此可以正常执行。之后由于sessionA的MDL读锁还没有释放，而sessionC需要MDL写锁，因此sessionC会被阻塞。之后所有要在表<code>t</code>上新申请MDL读锁的请求也会被sessionC阻塞。因此，现在这个表<code>t</code>变成了一个完全不可读写的表。而如果这张表上查询语句频繁，且客户端有重试机制的话，那么每超时一个请求，就会再发起一个session去请求，整个数据库的线程很快就会爆满。</p>
<p><strong>如何解决上述问题？</strong></p>
<p>在<code>ALTER TABLE</code>语句里面设定等待时间，如果在指定的等待时间内没有拿到MDL写锁，也不要阻塞后面的业务语句，而是先放弃，之后开发人员或者DBA再通过重试命令重复这个过程。</p>
<p>MariaDB已经合并了AliSQL的这个功能，所以这两个开元分支目前都支持DDL的<code>NOWAIT/WAIT N</code>语法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">ADD</span> column...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">ADD</span> column...</span><br></pre></td></tr></table></figure>

<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL的<strong>行锁是在引擎层由引擎自己实现的</strong>，行锁是针对数据表中行记录的锁。行锁也是MySQL中<strong>锁定粒度最小</strong>的一种锁，是<strong>针对索引字段加的锁</strong>。<strong>行级锁能大大减少数据库操作的冲突，并发度最高，但加锁开销也最大，加锁慢，可能会出现死锁</strong>。</p>
<p>例如：事务A在执行期间对需要更改的那一行加行锁并进行更新操作，事务A还并未提交。此时事务B开启，也想要更改该行数据，但由于行锁还未释放，则事务B获得行锁失败，陷入阻塞等待，只有当事务A提交或回滚，事务A的行锁释放后，事务B才能对该行数据加行锁，执行更新操作。</p>
<h3 id="两阶段协议"><a href="#两阶段协议" class="headerlink" title="两阶段协议"></a>两阶段协议</h3><p>两阶段协议指锁的添加和释放分别在两个阶段进行。也就是说，<strong>在InnoDB事务中，行锁是在需要的时候添加，不需要的时候不会立刻释放，而是要等到事务结束之后才释放</strong>。</p>
<p><strong>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量放在后面。</strong></p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p><img src="/img/article_content_img/MySQL%E6%AD%BB%E9%94%81.jpg" alt="MySQL死锁"></p>
<p>从上图可以看出，事务A在等待事务B释放id&#x3D;2的行锁，事务B在等待事务A释放id&#x3D;1的行锁，此时事务A和事务B就是在互相等待对方释放资源，陷入了死锁状态。</p>
<p>对于死锁，有两种解决方案：</p>
<ol>
<li>直接进入等待，直到超时。超时时间通过参数<code>innodb_lock_wait_timeout</code>进行设置，默认为50s。</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链中的某一个事务，让其他事务得以继续执行。可以将<code>innodb_deadlock_detect</code>参数设置为<code>on</code>来开启死锁检测，默认就是<code>on</code>。</li>
</ol>
<p>对于第一种方案，默认的超时时间为50s，即第一个被锁住的线程要等待50s才会超时退出，其他线程才能继续执行，这对于在线服务来说，是无法接受的。而如果将超时时间设置的很短，虽然可以很快解开死锁，但如果不是死锁，而是简单的锁等待的话，就会出现“误伤”。</p>
<p>对于第二种方案，<code>innodb_deadlock_detect</code>默认值是<code>on</code>，主动进行死锁检测会在发生死锁的时候快速发现并进行处理，但也存在额外负担。<strong>死锁检测的时间复杂度是O(n^2^)<strong>。假设有1000个并发线程同时更新同一行，那么死锁检测操作就是100万（1000*1000）的量级，这期间需要</strong>消耗大量的CPU资源</strong>。因此，就可能会出现<strong>CPU利用率很高，但每秒执行的事务量却很少</strong>的情况。</p>
<p><strong>那么如何解决由热点数据行更新导致的性能问题？</strong></p>
<ul>
<li><p>如果可以确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
</li>
<li><p>控制并发度。</p>
<ol>
<li><p>MySQL中间件做并发限制。</p>
</li>
<li><p>修改数据库源码：对于相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作。</p>
</li>
<li><p>将一行改成逻辑上的多行来减少锁冲突。例如：将影院账户总额这一条记录拆成逻辑上的10条记录，影院郑虎总额等于这10条记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来增加。这样每次冲突的概率就变成原来的1&#x2F;10，可以减少锁等待的个数，也就减少了死锁检测的CPU消耗。</p>
<p>但这种方案要根据实际业务逻辑做详细设计。假如是退票逻辑，那么账户余额可能会减少，因此就需要考虑一部分行记录变成0的情况，代码层面就需要对其做特殊处理。</p>
</li>
</ol>
</li>
</ul>
<h3 id="InnoDB中有哪几类行锁？"><a href="#InnoDB中有哪几类行锁？" class="headerlink" title="InnoDB中有哪几类行锁？"></a>InnoDB中有哪几类行锁？</h3><p>InnoDB行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB支持三种数据行锁定方式：</p>
<ul>
<li><p><strong>记录锁（Record Lock）：</strong>也被称为记录锁，属于单个行记录上的锁。</p>
</li>
<li><p><strong>间隙锁（Gap Lock）：</strong>锁定一个范围，即锁的就是两个值之间的空隙，不包括记录本身。间隙锁只有在可重复读隔离级别下才有效。（左开右开）</p>
<p><img src="/img/article_content_img/%E9%97%B4%E9%9A%99%E9%94%81.jpg" alt="MySQL死锁"></p>
</li>
<li><p><strong>临键锁（Next-Key Lock）：</strong>记录锁与间隙锁的结合，既锁定一个范围，也锁定记录行本身。主要为了解决幻读问题。（左开右闭）</p>
</li>
</ul>
<p>在可重复读隔离级别下，行锁默认使用Next-Key Lock，但是如果操作的索引是唯一索引或者主键索引，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock。</p>
<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S锁）和排它锁（Exclusive Lock，X锁）</p>
<ul>
<li><p>共享锁（S锁）：又称为读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取。（锁兼容）</p>
<p>若事务R对数据对象A加上S锁，则事务R可以读A但不能修改A，其他事务只能再对A加S锁，直到事务R释放S锁后，才不能加X锁。</p>
</li>
<li><p>排它锁（X锁）：又称为写锁&#x2F;独占锁，事务在修改记录的时候获取排它锁，不允许多个事务同时获取。（锁不兼容）</p>
<p>若事务R对数据对象A加上X锁，则事务R可以读、写A，其他事务在事务R没有释放X锁之前，无法对A加任何锁。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">S锁</th>
<th align="center">X锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S锁</td>
<td align="center">不冲突</td>
<td align="center">冲突</td>
</tr>
<tr>
<td align="center">X锁</td>
<td align="center">冲突</td>
<td align="center">冲突</td>
</tr>
</tbody></table>
<p><strong>意向锁：</strong>用来快速判断是否可以对某表使用表锁。意向锁属于表级锁，主要有以下两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS锁）：</strong>事务有意向对表中某些记录加S锁，则在加这个S锁之前，需要先对该表加IS锁。</li>
<li><strong>意向排它锁（Intention Exclusive Lock，IX锁）：</strong>事务有意向对表中某些记录加X锁，则在加这个X锁之前，需要先对该表加IX锁。</li>
</ul>
<p>意向锁之间都是相互兼容的，不存在任何冲突。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IS锁</th>
<th align="center">IX锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IS锁</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IX锁</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加S&#x2F;X锁之前，InnoDB会先获取该行数据所在表的对应的意向锁。</strong></p>
<p><strong>MySQL加行锁的方式：</strong></p>
<p><code>select ... for update</code>：对读取的记录加X锁</p>
<p><code>select ... lock in share mode</code>：对读取的记录加S锁</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题汇总（一）</title>
    <url>/2023/07/04/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h1><p>Redis是基于C语言开发的一个非关系型数据库（NoSQL），并且由于其数据都存储在内存中，所以Redis也是一个内存型数据库，读写速度非常快，常用作缓存。</p>
<p>Redis支持多种数据类型，可以满足不同的业务场景，包括：String、Hash、List、Set、Zset、Bitmap、Hyperloglog、GEO等。Redis支持事务、持久化、Lua脚本以及多种开箱即用的集群方案（Sentinel、Redis Cluster）。</p>
<h1 id="Redis有哪些优点和缺点？"><a href="#Redis有哪些优点和缺点？" class="headerlink" title="Redis有哪些优点和缺点？"></a>Redis有哪些优点和缺点？</h1><p><strong>优点：</strong></p>
<ul>
<li>基于内存操作，读写速度非常快</li>
<li>支持的数据类型丰富，可以满足多种不同的业务场景</li>
<li>支持数据持久化，有效避免数据丢失</li>
<li>Redis采用IO多路复用技术，多路指多个socket连接，复用指复用一个线程。Redis使用单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件。多路复用主要有三种技术：select、poll、epoll。</li>
<li>Redis是单线程的，避免线程切换开销以及多线程的竞争问题。这里的单线程是指在处理网络请求（一个或多个redis客户端连接）的时候只用一个线程来处理。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis的数据都是存储在内存中的，所以数据量过大时会对内存不友好。因此，需要设置键的过期时间、过期策略、内存淘汰策略。</li>
<li>对join或其他结构化查询的支持较差</li>
</ul>
<h1 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h1><p>Redis内部做了非常多的性能优化，比较重要的有以下三点：</p>
<ol>
<li>Redis基于内存操作，内存的访问速度是磁盘的上千倍。</li>
<li>Redis基于Reactor模式开发了一套高效的事件处理模型，主要是单线程事件循环和IO多路复用。</li>
<li>Redis内置了多种优化过后的数据结构实现，性能非常高。</li>
</ol>
<p><img src="/img/article_content_img/why-redis-so-fast.png" alt="为什么Redis这么快"></p>
<h1 id="Memcached和Redis有什么区别？"><a href="#Memcached和Redis有什么区别？" class="headerlink" title="Memcached和Redis有什么区别？"></a>Memcached和Redis有什么区别？</h1><p>Memcached和Redis都是常用的分布式缓存，但Memcached的使用率现在远不及Redis，因为Redis的功能相比Memcached更加强大。</p>
<p><strong>共同点：</strong></p>
<ul>
<li>都是基于内存操作的数据库，一般都用来当做缓存。</li>
<li>都具有过期策略。</li>
<li>性能都非常高</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>Memcached仅支持最简单的k&#x2F;v数据类型，即String类型，而Redis支持的数据类型更多，包括：String、List、Hash、Set、Zset、Bitmap、Hyperloglog、GEO等。</li>
<li>Memcached数据全部存储在内存中，没有持久化机制。而Redis具有RDB、AOF两种持久化方式，可以将数据持久化到磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Memcached没有灾难恢复机制，而Redis具有。因为Memcached的数据全部存储在内存且没有持久化机制，所以一旦发生断电、宕机等情况，数据将全部丢失，而Redis可以通过AOF和RDB文件进行数据的恢复。</li>
<li>Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据，而Redis是原生支持cluster模式的。</li>
<li>Memcached在服务器内存使用完之后，会报异常，而Redis则是可以将不用的数据放到磁盘上。</li>
<li>Memcached是多线程的、非阻塞IO复用的网络模型，而Redis是单线程的IO多路复用网络模型。</li>
<li>Memcached不支持发布订阅模型、Lua脚本、事务等功能，而Redis支持，并且Redis支持的编程语言也比Memcached多。</li>
<li>Memcached采用惰性删除，Redis采用定期删除与惰性删除结合的方式。</li>
</ul>
<h1 id="为什么要使用Redis-x2F-为什么要使用缓存？"><a href="#为什么要使用Redis-x2F-为什么要使用缓存？" class="headerlink" title="为什么要使用Redis&#x2F;为什么要使用缓存？"></a>为什么要使用Redis&#x2F;为什么要使用缓存？</h1><p>主要从高性能与高并发两个方面考虑：</p>
<p><strong>高性能：</strong></p>
<p>Redis是内存型数据库，读写速度非常快，因此效率就高。我们一般会将一些高频访问的数据放在缓存中，保证用户下一次访问这些数据的时候，直接从缓存中获取。</p>
<p><strong>高并发：</strong></p>
<p>一般像MySQL这类的数据库的QPS大概在1w左右（4核8G），但是Redis可以在单机模式下的QPS达到10w+，最高可达30w+。而如果是Redis集群，则QPS会更高。</p>
<p>因此，综合考虑以上两点，决定使用Redis，可以提高系统整体的并发。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数</p>
</blockquote>
<h1 id="Redis具有哪些使用场景？"><a href="#Redis具有哪些使用场景？" class="headerlink" title="Redis具有哪些使用场景？"></a>Redis具有哪些使用场景？</h1><p>虽然在日常使用过程中，我们都是将Redis用作缓存，但其实Redis支持的使用场景远不止有缓存，具体如下：</p>
<ol>
<li><strong>消息队列：</strong><ul>
<li>方式一：通过Redis自带的List数据结构来实现，List是一个双向列表，可以作为一个简单的消息队列使用。命令如下：<code>lpush/rpush ---&gt; rpop/lpop</code>。</li>
<li>方式二：通过发布&#x2F;订阅功能（Redis2.0引入）来实现，其解决了List实现消息队列没有哦广播机制的问题。</li>
<li>方式三：通过Redis自带的Stream数据结构来实现。Stream支持发布&#x2F;订阅模式，支持按照消费者组进行消费以及支持消息的持久化。</li>
</ul>
</li>
<li><strong>延时队列：</strong>Redisson内置了延时队列（基于Sorted set实现）。</li>
<li><strong>限流：</strong>一般通过Redis+Lua脚本来实现限流。具体可参考：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">Redis分布式限流器</a></li>
<li><strong>分布式锁：</strong>基于Redisson实现分布式锁。具体可参考：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">Redis分布式锁</a></li>
<li><strong>分布式Session：</strong>利用String或者Hash保存Session数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景：</strong>通过Redis以及Redis扩展（Redisson）提供的数据结构，可以很方便地完成多种复杂的业务场景，例如：通过Bitmap实现统计日活、月活的功能、通过Zset实现排行榜功能等。</li>
<li>……</li>
</ol>
<h1 id="缓存数据的处理流程"><a href="#缓存数据的处理流程" class="headerlink" title="缓存数据的处理流程"></a>缓存数据的处理流程</h1><p><img src="/img/article_content_img/Redis%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B.jpg" alt="Redis缓存流程"></p>
<p>从图中可以看出，用户发送请求获取数据后，首先需要判断缓存中是否有对应数据，如果缓存中有对应数据，那么直接返回即可。如果缓存中没有，则会去数据库（例如：MySQL）中查找。如果数据库中有对应数据，则先把该数据同步到缓存中，之后再返回数据。如果数据库中也没有对应数据，那么就返回一个空数据。</p>
<h1 id="Redis中常见的数据结构"><a href="#Redis中常见的数据结构" class="headerlink" title="Redis中常见的数据结构"></a>Redis中常见的数据结构</h1><p>Redis支持的数据结构非常多，例如：String、List、Hash、Set、Zset、Hyperloglog、GEO、Bitmap等。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String是Redis中最简单也是最常用的一种数据结构，可以用来存储任何类型的数据，例如：字符串、整数、浮点数、图片、序列化之后的对象等。</p>
<h3 id="String类型常用命令"><a href="#String类型常用命令" class="headerlink" title="String类型常用命令"></a>String类型常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">append key value	# 给这个key对应的值后面追加字符串。如果key不存在，相当于set key value</span><br><span class="line"></span><br><span class="line">strlen key	# 查看当前key对应的value的长度，即字符串长度</span><br><span class="line"></span><br><span class="line">incr key	# 自增1</span><br><span class="line"></span><br><span class="line">decr key	# 自减1</span><br><span class="line"></span><br><span class="line">incrby key increment	# 指定步长自增</span><br><span class="line"></span><br><span class="line">decrby key increment	# 指定步长自减</span><br><span class="line"></span><br><span class="line">getrange key start end	# 获取指定范围的字符串（类似于java中的substring）</span><br><span class="line"></span><br><span class="line">setrange key offset value	# 从offset处开始替换字符串，value是替换的新值</span><br><span class="line"></span><br><span class="line">setex key seconds value	# set值的时候，加过期时间</span><br><span class="line"></span><br><span class="line">setnx key value	# set if not exist：如果key不存在就set成功，如果key已经存在就set失败。</span><br><span class="line"></span><br><span class="line">mset key value [key value...]	# 批量设置值</span><br><span class="line"></span><br><span class="line">mget key [key...]	# 批量获取值</span><br><span class="line"></span><br><span class="line">msetnx key value [key value...]	# 批量设置值，如果key不存在就设置成功，如果key存在就失败。（这是一个原子性的操作）</span><br><span class="line"></span><br><span class="line">getset key value	# 先get再set。如果存在值，就获取原来的值，并设置新的值</span><br></pre></td></tr></table></figure>

<h3 id="String类型的应用场景"><a href="#String类型的应用场景" class="headerlink" title="String类型的应用场景"></a>String类型的应用场景</h3><ul>
<li><strong>常规数据的缓存：</strong>例如：Session、Token、序列化之后的对象、图片的路径等。</li>
<li><strong>计数场景：</strong>例如：文章点赞量、转发量，页面单位时间内的访问量等。</li>
<li><strong>分布式锁：</strong>利用<code>SETNX KEY VALUE</code>命令可以实现一个简易的分布式锁。</li>
<li>……</li>
</ul>
<h3 id="String类型底层实现"><a href="#String类型底层实现" class="headerlink" title="String类型底层实现"></a>String类型底层实现</h3><p>Redis是C语言编写的，但Redis并没有直接使用C语言传统的字符串（以空字符<code>\0</code>结尾的字符数组）表示，而是自己构建了一种名为<strong>简单动态字符串（Simple Dynamic String，SDS）</strong>的抽象类型来作为底层实现，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存的字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实SDS不仅是再String类型中有使用，SDS存在于任何使用到字符串对象的地方，即Redis数据库中，<strong>任何包含字符串值的键值对在底层都是由SDS实现的</strong>。</p>
<p>举个例子：</p>
<p>当客户端执行命令：<code>SET msg &quot;hello world&quot;</code>时，Redis将在数据库中创建一个新的键值对，其中：键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS，键值对的值是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS。</p>
<p>当客户端执行命令：<code>RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;orange&quot;</code>时，Redis将在数据库中创建一个新的键值对，其中：键值对的键是一个字符串对象，对象的底层实现是一个保存了字符串”fruits”的SDS，键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，第一个SDS保存着字符串”apple”，第二个SDS保存着字符串”banana”，第三个SDS保存着字符串”orange”。</p>
<p><strong>SDS相比于C字符串的区别</strong></p>
<ul>
<li><p><strong>获取字符串长度的时间复杂度不同：</strong>SDS获取字符串长度的时间复杂度为O(1)，C字符串获取字符串长度的时间复杂度为O(n)。</p>
<p>这是因为C字符串不记录字符串长度，所以想要获取其长度必须遍历整个字符串，对遇到的每个字符计数，直到遇到末尾的<code>\0</code>为止。</p>
<p>而SDS的<code>len</code>属性中记录了字符串长度，因此，直接读取<code>len</code>属性的值即可，不存在遍历字符串的过程。</p>
</li>
<li><p><strong>SDS可以杜绝缓冲区溢出：</strong>由于C字符串不记录自身长度，所以对字符串做修改的时候，就可能会造成溢出。举个例子，下图展示了在内存中紧邻的两个C字符串s1和s2，其中s1保存了字符串”Redis”，s2保存了字符串”MongoDB”。</p>
<p><img src="/img/article_content_img/C-String1.jpg" alt="在内存中紧邻的两个C字符串"></p>
<p>此时，当执行<code>strcat(s1, &quot;Cluster&quot;);</code>命令时，s1的数据将溢出到s2所在空间中，导致s2保存的内容被修改，如下图所示。</p>
<p><img src="/img/article_content_img/C-String2.jpg" alt="s1的内容溢出到s2所在的位置上"></p>
<p>而SDS在进行字符串修改时，会先判断当前空间是否满足修改所需的要求，如果空间不足，则SDS会将空间扩展到执行修改所需的大小，然后再执行修改操作，所以SDS既不需要手动修改SDS空间大小，也不会出现缓冲区溢出。</p>
</li>
<li><p><strong>空间预分配和惰性空间释放策略：</strong></p>
<p><strong>空间预分配：</strong></p>
<p><strong>用于优化SDS字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需的空间，还会为SDS分配额外的未使用空间。</strong></p>
<p>其中，额外分配的未使用空间数量由以下公式决定：</p>
<ul>
<li>如果对SDS进行修改之后，SDS的长度（<code>len</code>属性的值）小于1MB，那么程序分配和<code>len</code>属性同样大小的未使用空间，这时SDS的<code>len</code>属性的值将和<code>free</code>属性的值相同。例如：如果进行修改之后，SDS的<code>len</code>变成13字节，那么程序也会分配13字节的未使用空间，SDS的<code>buf</code>数组的实际长度将变成<code>13B + 13B + 1B = 27B</code>（额外的一个字节用于保存空字符）。</li>
<li>如果对SDS进行修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：如果进行修改之后，SDS的<code>len</code>变成30MB，那么程序会分配1MB的未使用空间，SDS的<code>buf</code>数组的实际长度将变成<code>30MB + 1MB + 1B</code>（额外的一个字节用于保存空字符）。</li>
</ul>
<p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，即SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次，提高了性能。</p>
<p><strong>惰性空间释放：</strong></p>
<p><strong>用于优化SDS字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用<code>free</code>属性将这些字节的数量记录起来，并等待将来使用。</strong></p>
<p>需要注意的是，SDS提供了相应的API，让我们可以在有需要时真正释放SDS的未使用空间，说不完全不必担心惰性空间释放策略会造成内存泄漏。</p>
</li>
<li><p><strong>二进制安全：</strong>C字符串中的字符必须符合某种编码（例如：ASCII），并且除了字符串末尾之外，字符串中不能包含任何空字符，否则最先被读入的空字符将被认为是字符串的末尾，从而停止对字符串的读取。因此，C字符串无法保存像图片、音频、视频、压缩文件等二进制数据。<strong>而SDS是可以存储二进制数据的，SDS API都会以处理二进制的方式来处理SDS存放在<code>buf</code>数组中的数据，程序不会对其中的数据做任何限制、过滤，数据在写入的时候是什么样子，读出的时候就还是什么样子。并且SDS使用的是<code>len</code>属性来判断是否字符串是否结束，而不是使用空字符来判断。</strong></p>
</li>
<li><p><strong>兼容部分C字符串函数：</strong>SDS可以重用<code>&lt;string.h&gt;</code>函数库，从而避免了不必要的代码重复。</p>
</li>
</ul>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
