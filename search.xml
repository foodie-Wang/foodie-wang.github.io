<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java语言</title>
    <url>/2023/06/13/Java%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="Java基础（面试常考）"><a href="#Java基础（面试常考）" class="headerlink" title="Java基础（面试常考）"></a>Java基础（面试常考）</h1><h2 id="1-Java语言有哪些特点？"><a href="#1-Java语言有哪些特点？" class="headerlink" title="1. Java语言有哪些特点？"></a>1. Java语言有哪些特点？</h2><ul>
<li><p>简单易学</p>
</li>
<li><p>面向对象（封装、继承、多态）</p>
</li>
<li><p>平台无关性（Java虚拟机实现平台无关性）</p>
<p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
</li>
<li><p>可靠性</p>
</li>
<li><p>安全性</p>
</li>
<li><p>支持多线程</p>
</li>
<li><p>支持网络编程</p>
</li>
<li><p>编译与解释共存</p>
<p>Java中会将源代码通过javac编译成字节码（class文件），然后运行时JVM会将字节码解释为对应的机器码，最后执行。</p>
<p>在常见的HotSpot虚拟机中，为了避免解释型语言带来的执行效率低问题，采用了JIT compile(just in time compilation)即时编译技术，将运行频率很高的字节码直接编译为机器指令执行来提高性能。</p>
<p>这就是我们为什么经常会说 Java 是编译与解释共存的语言的原因。</p>
</li>
<li><p>会自动进行垃圾回收（GC）</p>
</li>
</ul>
<h2 id="2-JDK、JRE、JVM有什么区别？"><a href="#2-JDK、JRE、JVM有什么区别？" class="headerlink" title="2. JDK、JRE、JVM有什么区别？"></a>2. JDK、JRE、JVM有什么区别？</h2><p>JDK：JDK是Java Development Kit的缩写，它的功能是最全的Java SDK。它拥有JRE所拥有的的一切，还有编译器（Javac）和工具（Javadoc和jdb）。它能够创建和编译程序。</p>
<p>JRE：JRE是Java Runtime Environment的缩写，是Java运行时环境。它是运行已编译Java程序所需的所以内容的集合，包括JVM，Java类库，Java命令和其他一些基础构件。但是它不能用于创建新程序。</p>
<p>JVM：Java虚拟机是运行Java运行字节码的虚拟机。JVM有针对不同系统的特定实现，目的是使用相同的字节码，都会给出相同的结果。</p>
<h2 id="3-Java和C-的区别？"><a href="#3-Java和C-的区别？" class="headerlink" title="3. Java和C++的区别？"></a>3. Java和C++的区别？</h2><ul>
<li>都是面向对象语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，接口是多继承的。C++支持类的多继承</li>
<li>Java有垃圾回收机制，不需要手动释放无用内存</li>
<li>Java语言中没有结束符这一概念。C语言中，字符串或字符数组最后都会有一个额外的字符 ‘ \0 ‘ 来表示结束</li>
</ul>
<h2 id="4-字符型常量和字符串常量有什么区别？"><a href="#4-字符型常量和字符串常量有什么区别？" class="headerlink" title="4. 字符型常量和字符串常量有什么区别？"></a>4. 字符型常量和字符串常量有什么区别？</h2><ul>
<li>字符型常量是用单引号引起来的一个字符，字符串常量是用双引号引起来的零个或多个字符</li>
<li>字符型常量是可以用来进行数学运算的，因为一个字符对应一个ASCII码值。而字符串常量不行，因为字符串常量代表的是地址值</li>
<li>字符型常量占两个字节，字符串常量占多个字节</li>
</ul>
<h2 id="5-抽象类与接口的区别？"><a href="#5-抽象类与接口的区别？" class="headerlink" title="5. 抽象类与接口的区别？"></a>5. 抽象类与接口的区别？</h2><ul>
<li>抽象类与接口都不能直接进行实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量也必须指向实现所有接口的类对象</li>
<li>抽象类必须保证有一个类要去继承它，且这个类只能继承一个抽象类，否则会报错。而接口也要被类去实现。</li>
<li>接口里定义的变量都是被static、final修饰的，抽象类中的变量就是普通变量</li>
<li>抽象类可以没有抽象方法，但是有抽象方法的一定是抽象类</li>
<li>一个类可以实现多个接口，接口与接口是多继承的</li>
<li>接口中没有this指针，没有构造函数，不能拥有实例变量或实例方法</li>
<li>抽象类不能再Java8中的lambda表达式中使用</li>
</ul>
<h2 id="6-字节流与字符流的区别？（StringBuilder和StringBuffer的区别）"><a href="#6-字节流与字符流的区别？（StringBuilder和StringBuffer的区别）" class="headerlink" title="6. 字节流与字符流的区别？（StringBuilder和StringBuffer的区别）"></a>6. 字节流与字符流的区别？（StringBuilder和StringBuffer的区别）</h2><ul>
<li>StringBuffer和StringBuilder都继承自AbstractStringBuilder类，都用来存储字符串，但是不像String那样有final修饰，所以是可变的。</li>
<li>StringBuffer类中方法都加了synchronized同步锁，所以线程安全。而StringBuilder没有加synchronized同步锁，所以线程不安全。</li>
<li>StringBuilder适用于单线程下对字符串缓冲区大量字符串的操作。而StringBuffer适用于多线程下对字符串缓冲区大量字符串的操作。</li>
<li>StringBuilder每次都需要复制一次字符数组，再构造一个字符串。而StringBuffer每次获取toString都会直接使用缓冲区的。toStringCache的值来构造一个字符串。</li>
<li>性能上来说，StringBuilder和StringBuffer都是对变量的操作，对变量的操作是直接对该对象本身进行更改就行，不会进行重复的创建和回收。所以在运行速度上比较快。</li>
</ul>
<h2 id="7-Java中IO流分为几种"><a href="#7-Java中IO流分为几种" class="headerlink" title="7. Java中IO流分为几种"></a>7. Java中IO流分为几种</h2><p>按流向分：输入流、输出流</p>
<p>按操作单元分：字节流、字符流</p>
<p>按流的角色分：节点流、处理流</p>
<p>InputStream &#x2F; Reader：所有的输入流的基类。InputStream是字节输入流，Reader是字符输入流。</p>
<p>OutputStream &#x2F; Writer：所有的输出流的基类。OutputStream是字节输出流，Writer是字符输出流。</p>
<h2 id="8-为什么有了字节流还要有字符流？"><a href="#8-为什么有了字节流还要有字符流？" class="headerlink" title="8. 为什么有了字节流还要有字符流？"></a>8. 为什么有了字节流还要有字符流？</h2><p>字符流是由Java虚拟机将字节转换得到的，这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所有I&#x2F;O流提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。</p>
<ul>
<li>音频，视频等媒体文件用字节流比较好</li>
<li>涉及到字符的话使用字符流比较好</li>
</ul>
<h2 id="9-static与final关键字，final修饰的数组可以改变吗？"><a href="#9-static与final关键字，final修饰的数组可以改变吗？" class="headerlink" title="9. static与final关键字，final修饰的数组可以改变吗？"></a>9. static与final关键字，final修饰的数组可以改变吗？</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static可以修饰变量、方法、代码块</p>
<ol>
<li><p><strong>static修饰变量和方法</strong></p>
<ul>
<li><p>被static修饰的变量属于类变量，可以通过<strong>类名.变量名</strong>直接引用，而不需要new出一个类来</p>
</li>
<li><p>被static修饰的方法属于类方法，可以通过<strong>类名.方法名</strong>直接引用，而不需要new出一个类来</p>
</li>
</ul>
<p>静态资源属于类，但是是独立于类存在的。从JVM的类加载机制的角度讲，<strong>静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的</strong>。类的初始化早于类的new。所以对于静态资源来说，它是不可能知道一个类中有哪些非静态资源的。但是对于非静态资源来说就不一样了，由于它是new出来之后产生的，因此属于类的这些东西它都能认识。综上所述：</p>
<ul>
<li><p>&#x3D;&#x3D;静态方法能不能引用非静态资源？不能，new的时候才会产生的东西，对于初始化后就存在的静态资源来说，根本不认识它。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;静态方法里面能不能引用静态资源？可以，因为都是类初始化的时候加载的，大家相互都认识。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;非静态方法里面能不能引用静态资源？可以，非静态方法就是实例方法，那是new之后才产生的，那么属于类的内容它都认识。&#x3D;&#x3D;</p>
</li>
</ul>
</li>
<li><p><strong>static修饰代码块</strong></p>
<ul>
<li>静态块里面的代码只执行一次，且只在初始化类的时候执行</li>
<li>静态资源的加载顺序是严格按照静态资源的定义顺序来加载的</li>
<li>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问</li>
<li>静态代码块是严格按照父类静态代码块-&gt;子类静态代码块的顺序加载的，且只加载一次</li>
</ul>
</li>
<li><p><strong>static修饰类</strong></p>
<p>如果static修饰一个类，那这个类一定是一个匿名内部类。像线程池ThreadPoolExecutor中的四种拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy就是静态内部类。</p>
</li>
<li><p><strong>import static</strong></p>
<p>import static是JDK1.5之后的新特性，这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名.资源名，可以直接使用资源名。注意一下，<strong>import static</strong>必须这么写，而不能写成static import。举个例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="number">6</span>     &#123;</span><br><span class="line"><span class="number">7</span>         System.out.println(sin(<span class="number">2.2</span>));</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这么写意味着我导入了Math下的所有静态资源，main函数里面我就可以直接用sin(2.2)而不需要使用Math.sin(2.2)了。注意一下，要写**import static java.lang.Math.***，最后的“.*”不可少，有了这两个字符才意味着导入的是Math下的所有静态资源，写成import static java.lang.Math是有问题的。当然，我们也可以指定只导入某个静态资源，比如只导入Math下sin这个方法而不导入Math下的所有静态资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.sin;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"><span class="number">6</span>     &#123;</span><br><span class="line"><span class="number">7</span>         System.out.println(sin(<span class="number">2.2</span>));</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这么写也是没问题的。导入静态变量也是一样，有兴趣的可以自己试一下。对于import static，个人的态度是：</p>
<p>1、简化了一些操作，比如静态导入Math下的所有静态资源，在频繁使用Math类下静态资源的地方，可以少些很多“Math.”</p>
<p>2、降低了代码的可读性</p>
<p>建议在某些场景下导入特定的静态资源，不建议使用“.*”的导入方式。</p>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>使用final修饰的类不能被继承</li>
<li>使用final修饰的方法不能被重写</li>
<li>使用final修饰的变量不可变，如果该变量是基本数据类型，初始化之后成员变量的值不能被改变。如果是引用数据类型，那么它只能指向初始化时的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。</li>
</ul>
<p>使用final关键字的好处：</p>
<ol>
<li>final方法比非final快一些</li>
<li>final关键字提高了性能。JVM和Java应用都会缓存final变量。</li>
<li>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</li>
<li>使用final关键字，JVM会对方法、变量及类进行优化。</li>
</ol>
<h2 id="10-Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？"><a href="#10-Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？" class="headerlink" title="10. Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？"></a>10. Java泛型了解吗？什么是类型擦除？介绍一下常用通配符？</h2><p>Java泛型是JDK5引入的一个新特性，泛型提供了编译时类型安全检测机制。泛型是的本质是参数化类型。</p>
<p>泛型一般有三种使用方式：泛型类、泛型方法、泛型接口</p>
<p>常用通配符：T、E、K、V、?</p>
<ul>
<li>T（type）：具体的Java类型</li>
<li>E（element）：代表element</li>
<li>K、V（Key、Value）：分别代表Java键值中的key、value</li>
<li>？：表示不确定的Java类型</li>
</ul>
<p>Java的泛型是伪泛型，因为在编译期间，所有的泛型信息都会被擦除，这就是类型擦除。</p>
<h2 id="11-x3D-x3D-和equals的区别？"><a href="#11-x3D-x3D-和equals的区别？" class="headerlink" title="11. &#x3D;&#x3D;和equals的区别？"></a>11. &#x3D;&#x3D;和equals的区别？</h2><p>（1）基本类型比较</p>
<ol>
<li>使用“&#x3D;&#x3D;”比较的是值是否相等</li>
<li>基本数据类型无equals方法</li>
</ol>
<p>（2）引用数据类型</p>
<ol>
<li><p>重写了equals方法，比如String：</p>
<p>第一种情况：使用“&#x3D;&#x3D;”比较的是String的引用是否指向了同一块内存</p>
<p>第二种情况：使用equals方法比较的是String的引用的对象的内容是否相等。</p>
</li>
<li><p>没有重写equals方法：比如User类等自定义类</p>
<p>“&#x3D;&#x3D;”和equals没有区别，比较的都是引用是否指向了同一块内存。</p>
</li>
</ol>
<h2 id="12-hashcode-与equals，为什么重写equals时必须重写hashcode-？"><a href="#12-hashcode-与equals，为什么重写equals时必须重写hashcode-？" class="headerlink" title="12. hashcode()与equals，为什么重写equals时必须重写hashcode()？"></a>12. hashcode()与equals，为什么重写equals时必须重写hashcode()？</h2><p>hashcode()的作用就是获取哈希码，也叫散列码，作用是为了确定该对象在哈希表中的索引位置</p>
<p>如果两个对象相等，那么hashcode一定也相同，调用equals时也都会返回true。但是两个对象有相同的hashcode值，他们也不一定是相等的。因此equals方法被覆盖过，则hashcode方法也必须被覆盖。</p>
<ol>
<li>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率。</li>
<li>保证是同一个对象，因为如果重写了equals没有重写hashcode，会出现equals相同，hashcode不相同的对象。如果重写了hashcode而没有重写equals，那么会出现hashcode相同，equals不相同的对象。</li>
</ol>
<h2 id="13-方法重载和方法重写？"><a href="#13-方法重载和方法重写？" class="headerlink" title="13. 方法重载和方法重写？"></a>13. 方法重载和方法重写？</h2><p>方法重载：重载就是同样的一个方法能够根据输入数据的不同，做出不同的结果处理。即：发生在同一个类中，方法名相同，参数类型不同，个数不同，顺序不同，方法返回值与权限修饰符可以不同。</p>
<p>方法重写：重写就是当子类继承了父类相同的方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类的方法。</p>
<p>方法重写时需要遵循“两同两小一大”</p>
<ul>
<li>两同：方法名相同，参数列表相同</li>
<li>两小：子类方法返回值类型应该小于父类方法返回值类型。子类方法声明抛出的异常类应该比父类方法抛出的异常类更小或相等</li>
<li>一大：子类方法的访问权限应该比父类方法的访问权限更大或相等</li>
</ul>
<h2 id="14-深拷贝、浅拷贝"><a href="#14-深拷贝、浅拷贝" class="headerlink" title="14. 深拷贝、浅拷贝"></a>14. 深拷贝、浅拷贝</h2><p>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。新对象跟原对象不共享内存，修改新对象不会改到原对象</p>
<p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。浅拷贝只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</p>
<h2 id="15-面向对象的三大特征"><a href="#15-面向对象的三大特征" class="headerlink" title="15. 面向对象的三大特征"></a>15. 面向对象的三大特征</h2><p>封装、继承、多态</p>
<ul>
<li><p>封装：</p>
<p>封装就是把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象内部信息</p>
</li>
<li><p>继承：</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是无法访问，只能拥有。</li>
<li>子类可以拥有自己的属性和方法（对父类进行扩展）</li>
<li>子类可以用自己的方式实现父类的方法（方法重写）</li>
</ol>
</li>
<li><p>多态：</p>
<p>多态，表示一个对象具有多种状态。父类引用指向子类对象。方法重载也是多态的一种体现。</p>
</li>
</ul>
<h2 id="16-import-java和javax的区别"><a href="#16-import-java和javax的区别" class="headerlink" title="16. import java和javax的区别"></a>16. import java和javax的区别</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，&#x3D;&#x3D;javax 当时只是扩展 API 包来使用&#x3D;&#x3D;。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包太麻烦了，最终可能会破坏一堆现有的代码。因此，&#x3D;&#x3D;最终决定 javax 包将成为标准API的一部分。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;所以，实际上java和javax没有区别。这都是一个名字。&#x3D;&#x3D;</p>
<h2 id="17-创建一个对象用什么运算符？对象实例与对象引用有何不同？"><a href="#17-创建一个对象用什么运算符？对象实例与对象引用有何不同？" class="headerlink" title="17. 创建一个对象用什么运算符？对象实例与对象引用有何不同？"></a>17. 创建一个对象用什么运算符？对象实例与对象引用有何不同？</h2><p>使用new关键字创建对象。</p>
<p>new创建的对象实例是在堆内存中的，而对象引用指向对象实例，存放在栈内存中。一个对象引用可以指向一个或零个对象；一个对象可以有n个引用指向它。</p>
<h2 id="18-什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#18-什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="18. 什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>18. 什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><p>方法的返回值就是我们获取到的某个方法体中的代码执行之后产生的结果。</p>
<p>返回值的作用：接收方法体执行结束之后产生的结果，使得其可以用于后续其他的操作</p>
<h2 id="19-什么是哈夫曼树"><a href="#19-什么是哈夫曼树" class="headerlink" title="19. 什么是哈夫曼树"></a>19. 什么是哈夫曼树</h2><p>给定N个权值作为N个<a href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239">叶子结点</a>，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。</p>
<h2 id="20-什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？"><a href="#20-什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？" class="headerlink" title="20. 什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？"></a>20. 什么是满二叉树、什么是完全二叉树、什么是平衡二叉树？</h2><p>满二叉树：除了最后一层没有子节点外，其余每一层上所有节点都有两个子节点的二叉树叫满二叉树。也就是深度为k，且有2的k次方-1个节点的二叉树称为满二叉树。</p>
<p>完全二叉树：如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。</p>
<p>平衡二叉树：任意节点的子树的高度差都小于等于1。</p>
<h2 id="21-反射机制"><a href="#21-反射机制" class="headerlink" title="21. 反射机制"></a>21. 反射机制</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象属性及方法的功能称之为Java语言的反射机制。</p>
<h2 id="22-静态编译和动态编译"><a href="#22-静态编译和动态编译" class="headerlink" title="22. 静态编译和动态编译"></a>22. 静态编译和动态编译</h2><ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：在运行时，确定类型，绑定对象</li>
</ul>
<h2 id="23-反射机制的优缺点？"><a href="#23-反射机制的优缺点？" class="headerlink" title="23. 反射机制的优缺点？"></a>23. 反射机制的优缺点？</h2><p>优点：运行期类型的判断，动态加载类，提高代码灵活度。</p>
<p>缺点：性能比直接的Java代码要慢的多，不够安全。</p>
<h2 id="23-反射的应用场景？"><a href="#23-反射的应用场景？" class="headerlink" title="23. 反射的应用场景？"></a>23. 反射的应用场景？</h2><p>JDBC连接数据库使用<code>Class.forName(driver);</code>，通过反射加载数据库驱动</p>
<p>Spring的IOC、AOP中使用了反射</p>
<p>动态配置实例的属性</p>
<p>Web服务器中利用反射调用了Servlet的服务方法</p>
<h2 id="24-什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？"><a href="#24-什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？" class="headerlink" title="24. 什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？"></a>24. 什么叫对象的序列化？什么叫反序列化？实现对象的序列化需要做哪些工作？</h2><p>将对象中数据编码为字节序列的过程叫对象的序列化</p>
<p>将字节序列重新反向解码为对象数据的过程称之为反序列化</p>
<p>Java提供了API来实现序列化，但要遵守如下规定：</p>
<ul>
<li>要实现序列化接口（Serializable）</li>
<li>为了保持序列化过程稳定，建议在类中添加序列化版本号</li>
<li>如果不想被序列化，加<strong>transient</strong>关键字</li>
</ul>
<h2 id="25-泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？"><a href="#25-泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？" class="headerlink" title="25. 泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？"></a>25. 泛型中存在类型擦除，在编译期间，所有的泛型信息都会被擦除，那为什么反射能够获取到泛型信息？</h2><p>泛型的类型擦除是有范围的，定义在类上的泛型信息是不会被擦除的。Java编译器仍在class文件以Signature属性的方式保留了泛型信息。</p>
<p>Type作为顶级接口，Type下还有几种类型，比如TypeVariable，ParameterizedType，WildCardType，GenericArrayType以及Class。通过这些接口，我们就可以在运行时获取泛型相关的信息。</p>
<h2 id="26-Java异常"><a href="#26-Java异常" class="headerlink" title="26. Java异常"></a>26. Java异常</h2><p>所有异常都有一个共同的祖先，Throwable类。Throwable类有两个重要的子类，Exception和Error。</p>
<p>Exception是能被程序本身处理的（try-catch）</p>
<p>Error不能被程序本身处理，只能尽量避免</p>
<p>Exception又可以分为 &#x3D;&#x3D;受检查异常&#x3D;&#x3D; 和 &#x3D;&#x3D;不受检查异常&#x3D;&#x3D; ，除了RuntimeException及其子类外，都是受检查异常，常见的受检查异常有：SQLException、IOException、ClassNotFoundException</p>
<p>常见的不受检查异常有：NullPointException、ArrayIndexOfBoundsException、ClassCastException….</p>
<h2 id="27-finally在哪些情况下不会执行？"><a href="#27-finally在哪些情况下不会执行？" class="headerlink" title="27. finally在哪些情况下不会执行？"></a>27. finally在哪些情况下不会执行？</h2><ul>
<li>在try或finally中用了System.exit()退出程序，则finally不会执行。但是如果System.exit()在异常语句之后，finally还会执行。</li>
<li>程序所在的线程死亡，finally不会执行</li>
<li>关闭CPU，finally不会执行</li>
<li>在进入try之前，就已经返回了，那就不会执行finally</li>
</ul>
<h2 id="28-javac命令和java命令做了什么事情？"><a href="#28-javac命令和java命令做了什么事情？" class="headerlink" title="28. javac命令和java命令做了什么事情？"></a>28. javac命令和java命令做了什么事情？</h2><p>javac：负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。</p>
<p>java：负责运行的部分，会启动jvm加载运行时所需要的类库，并对class文件进行执行。一个文件要被执行，必须要有一个执行的起始点，这个起始点就是main()函数。</p>
<h2 id="29-java数据类型"><a href="#29-java数据类型" class="headerlink" title="29. java数据类型"></a>29. java数据类型</h2><p>基本数据类型：byte、short、int、long、float、double、char、boolean</p>
<p>引用数据类型：类、接口、数组</p>
<p>int：4个字节</p>
<p>short：2个字节</p>
<p>long：8个字节</p>
<p>byte：1个字节</p>
<p>float：4个字节</p>
<p>double：8个字节</p>
<p>char：2个字节</p>
<p>两个数相加，如果一个是double，另一个转换为double。</p>
<p>否则，有一个是float，则另一个转换为float。</p>
<p>否则，有一个是long，则另一个转换为long。</p>
<p>级别从低到高：byte、char、int（这三个平级） - &gt; int - &gt; long - &gt; float - &gt; double</p>
<p>类型转换时可能会出现精度丢失或者数据无法表示</p>
<ul>
<li>精度丢失：float只能有24位来确定精度，而int是32位。int转float可能丢失末尾的有效数字</li>
<li>无法表示：比如float存放一个1e30，转换为int是无法表示的，因为超过了int的最大值</li>
</ul>
<h2 id="30-throw和throws的区别？"><a href="#30-throw和throws的区别？" class="headerlink" title="30. throw和throws的区别？"></a>30. throw和throws的区别？</h2><p>throw用于抛出异常对象，后面跟的是异常对象，throw用于函数内</p>
<p>throws用于抛出异常类，后面跟的是异常类，可以跟多个，用逗号隔开。throws用于方法上（函数上）</p>
<h2 id="31-自动装箱、自动拆箱？"><a href="#31-自动装箱、自动拆箱？" class="headerlink" title="31. 自动装箱、自动拆箱？"></a>31. 自动装箱、自动拆箱？</h2><p>装箱就是自动将基本数据类型转换为包装器类型</p>
<p>拆箱就是自动将包装器类型转换为基本数据类型</p>
<p>int &lt;-&gt; Integer</p>
<p>byte &lt;-&gt; Byte</p>
<p>long &lt;-&gt; Long</p>
<p>float &lt;-&gt; Float</p>
<p>double &lt;-&gt; Double</p>
<p>char &lt;-&gt; Character</p>
<p>boolean &lt;-&gt; Boolean</p>
<p>自动装箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> a; 	<span class="comment">//这一步相当于执行了Integer b = Integer.valueOf(a);</span></span><br></pre></td></tr></table></figure>

<p>自动拆箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> b;		<span class="comment">//这一步相当于执行了int a = b.intValue();</span></span><br></pre></td></tr></table></figure>

<h2 id="32-JDBC操作数据库的基本步骤"><a href="#32-JDBC操作数据库的基本步骤" class="headerlink" title="32. JDBC操作数据库的基本步骤"></a>32. JDBC操作数据库的基本步骤</h2><ol>
<li>加载（注册）数据库驱动（到JVM）</li>
<li>建立（获取）数据库连接</li>
<li>创建（获取）数据库操作对象</li>
<li>定义操作的SQL语句</li>
<li>执行数据库操作</li>
<li>获取并操作结果集</li>
<li>关闭对象，回收数据库资源（关闭结果集 -&gt; 关闭数据库操作对象 -&gt; 关闭连接）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:8080/test?characterEncoding=utf-8&amp;serverTimeZone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.加载数据库驱动（成功加载后，会将Driver类的实例注册到DriverManager类中）</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">            <span class="comment">//2.获取数据库连接</span></span><br><span class="line">            conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">            <span class="comment">//3.获取数据库操作对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">//4.定义SQL语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = 100&quot;</span>;</span><br><span class="line">            <span class="comment">//5.执行数据库操作</span></span><br><span class="line">            rs = stmt.excuteQuery(sql);</span><br><span class="line">            <span class="comment">//6.获取并操作结果集</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                System.out.println(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//7.关闭对象，回收数据库资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs != <span class="literal">null</span>) &#123;	<span class="comment">//关闭结果集对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stmt != <span class="literal">null</span>) &#123;	<span class="comment">//关闭数据库操作对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="literal">null</span>) &#123;	<span class="comment">//关闭数据库连接对象</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-Statement和PreparedStatement有什么区别？"><a href="#33-Statement和PreparedStatement有什么区别？" class="headerlink" title="33. Statement和PreparedStatement有什么区别？"></a>33. Statement和PreparedStatement有什么区别？</h2><ul>
<li>PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加安全性（减少SQL注入攻击的可能性）</li>
<li>PreparedStatement中SQL语句是可以带参数的，避免了用字符串拼接SQL语句的麻烦和不安全</li>
<li>当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快</li>
</ul>
<h2 id="34-Class-forName和ClassLoader的区别？"><a href="#34-Class-forName和ClassLoader的区别？" class="headerlink" title="34. Class.forName和ClassLoader的区别？"></a>34. Class.forName和ClassLoader的区别？</h2><p>Class.forName的源码中，有一个forName0方法，这个forName0方法的第二个参数设置为了true，这个参数代表是否对加载的类进行初始化。设置为true时会对类进行初始化，会执行类中的静态代码块，以及对静态变量的赋值等操作。</p>
<p>而ClassLoader并不会对类进行初始化</p>
<h2 id="35-float和double的区别？"><a href="#35-float和double的区别？" class="headerlink" title="35. float和double的区别？"></a>35. float和double的区别？</h2><ul>
<li>float是单精度类型，精度是&#x3D;&#x3D;8&#x3D;&#x3D;位有效数字，占用4个字节，取值范围10^-38^ ~10^38^。</li>
<li>double是双精度类型，精度是&#x3D;&#x3D;17&#x3D;&#x3D;位有效数字，占用8个字节，取值范围是10^-308^~10^308^。</li>
<li>如果不声明，则默认为double类型，如果要使用float的话，需要在后面加 f 。例如：float a &#x3D; 1.0f</li>
<li>float是8位有效数字，第七位会产生四舍五入（5及5一下都舍去）</li>
</ul>
<h2 id="36-既然反射可以拿到private里的值，那private的意义在哪？"><a href="#36-既然反射可以拿到private里的值，那private的意义在哪？" class="headerlink" title="36. 既然反射可以拿到private里的值，那private的意义在哪？"></a>36. 既然反射可以拿到private里的值，那private的意义在哪？</h2><ol>
<li>Java里的private修饰符不是为了绝对的安全设计的，而是对用户常规使用java的一种约束。就好比在饭店厨房门口挂一个闲人免进的牌子，但你还是能够通过其他方法进去。</li>
<li>private的意义是OOP（面向对象编程）的封装概念。</li>
<li>setAccessable(true)，这行代码取消了java权限控制检查，会产生安全隐患，但是提高了反射的速度。</li>
</ol>
<h2 id="37-一个java文件写多个类，会生成多少个class文件？"><a href="#37-一个java文件写多个类，会生成多少个class文件？" class="headerlink" title="37. 一个java文件写多个类，会生成多少个class文件？"></a>37. 一个java文件写多个类，会生成多少个class文件？</h2><p>一个java文件写多个类，除去内部类，剩下的每个普通类都会生成一个class文件。</p>
<h2 id="38-Java语言的6个设计原则。"><a href="#38-Java语言的6个设计原则。" class="headerlink" title="38. Java语言的6个设计原则。"></a>38. Java语言的6个设计原则。</h2><ul>
<li><p>遵循单一职责原则</p>
<p>一个类只专注于做一件事<br>高内聚，低耦合</p>
</li>
<li><p>开放-封闭原则</p>
<p>对拓展开放，对修改关闭（尽可能不动原有代码进行拓展）<br>高内聚，低耦合<br>为达到目的，需对系统进行抽象化设计（关键）</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012552846.png" alt="image-20210708012552846"></p>
</li>
<li><p>里氏代换原则（LSP）</p>
<p>子类必须能够替换它们的基类型，基类与子类可互换，客户端没有察觉情况下<br>低耦合<br>很容易实现同一父类下的各个子类的互换，而客户端可以毫不察觉</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012701645.png" alt="image-20210708012701645"></p>
<p>士兵只能使用WeaponGun，而无法使用ToyGun杀敌，如果使用ToyGun将会出错。这就是里氏替换原则。</p>
</li>
<li><p>依赖倒置原则</p>
<p>这个是开闭原则的基础。</p>
<p>具体内容：面向接口编程，依赖于抽象而不依赖于细节。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle）</p>
<p>使用多个专一功能的接口比使用一个总接口总要好，但不能过度<br>一个接口不能过于臃肿<br>高内聚<br>会使一个软件系统功能拓展时，修改的压力不会影响到别的对象那去</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012807116.png" alt="image-20210708012807116"></p>
<p>Model只要满足好身材这个条件，就有可能成为模特，漂亮女孩满足好身材和好。AngelaBaby即有好身材又好。</p>
</li>
<li><p>迪米特法则（Law of Demeter）</p>
<p>又叫最少知识原则<br>对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系<br>低耦合<br>类知道其他类应尽量少<br>类可以访问其他类的方法或者属性也应尽量少</p>
<p><img src="C:\Users\FoodieWang\AppData\Roaming\Typora\typora-user-images\image-20210708012836504.png" alt="image-20210708012836504"></p>
<p>如果Lily和Jack自己做hamburg那么就会与Vegetable、Meat、Bread产生千丝万缕关系。上图，则由KFC来做，这样Lily和Jack就只与Hamburg有关关联，与材料就没有关联了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/2023/06/13/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><p>1、测试测试</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端</title>
    <url>/2023/06/13/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="CSS学习"><a href="#CSS学习" class="headerlink" title="CSS学习"></a>CSS学习</h1><p>测试测试</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题汇总（一）</title>
    <url>/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、OSI七层模型、TCP-x2F-IP四层模型与五层模型介绍"><a href="#一、OSI七层模型、TCP-x2F-IP四层模型与五层模型介绍" class="headerlink" title="一、OSI七层模型、TCP&#x2F;IP四层模型与五层模型介绍"></a>一、OSI七层模型、TCP&#x2F;IP四层模型与五层模型介绍</h1><p>OSI七层模型（从顶到下）分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。</p>
<p>TCP&#x2F;IP四层模型（从顶到下）分别是：应用层、传输层、网际层、网络接口层。</p>
<p>五层模型（从顶到下）分别是：应用层、传输层、网络层、数据链路层、物理层。</p>
<p>OSI七层模型中每一层的功能与常见协议如下：</p>
<ul>
<li><p><strong>应用层：</strong>通过应用进程间的交互来完成特定的网络应用。</p>
<p>常见协议：SMTP（简单邮件传输协议）、FTP（文件传输协议）、DNS（域名系统）、HTTP（超文本传输协议）、POP3（邮局协议）、Telnet（远程登录协议）…</p>
</li>
<li><p><strong>表示层：</strong>主要用于处理两个通信系统间信息交换的表示方式，包括：数据的加密和解密、数据的压缩和解压缩、数据的编码和解码等。</p>
</li>
<li><p><strong>会话层：</strong>建立、维护和重连应用程序之间的会话。</p>
</li>
<li><p><strong>传输层：</strong>为两台主机进程之间的通信提供通用的数据传输服务。</p>
<p>常见协议：TCP（传输控制协议）、UDP（用户数据报协议）。</p>
</li>
<li><p><strong>网络层：</strong>把传输层产生的报文段或用户数据报封装成分组和包进行传送。此外，还会寻找合适的网间路由和交换节点，保证数据的及时传输。</p>
<p>常见协议：IP（网际互联协议）、IPv6（网际互联协议第6版），ICMP（互联网控制信息协议）、IGMP（互联网组管理协议）、OSPF（开放最短路径优先协议）…</p>
</li>
<li><p><strong>数据链路层：</strong>将网络层传下来的IP数据报组装成帧，在两个相邻节点之间的链路上进行帧的传输。每一帧包括必要的控制信息（同步信息、差错控制、地址信息等）。</p>
</li>
<li><p><strong>物理层：</strong>利用物理传输介质为数据链路层提供物理连接，实现相邻计算机之间比特流的透明传输。</p>
</li>
</ul>
<p><img src="/img/article_content_img/osi-model.png" alt="OSI七层模型图"></p>
<h1 id="二、常见协议简介"><a href="#二、常见协议简介" class="headerlink" title="二、常见协议简介"></a>二、常见协议简介</h1><ul>
<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）：</strong> 基于TCP协议，使用“客户端&#x2F;服务器”工作模式，是一种用于传输超文本和多媒体内容的协议，主要是为Web浏览器与Web服务器之间的通信而设计的。当我们使用浏览器浏览网页时，网页就是通过HTTP请求进行加载的。HTTP是一种<strong>无状态</strong>协议，即无法记录客户端用户的状态。因此，一般采用会采用Session来记录客户端用户的状态。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）：</strong>基于TCP协议，是一种用于发送电子邮件的协议。（注：SMTP只负责发送邮件，不负责接收邮件）</li>
<li><strong>FTP（File Transfer Protocol，文件传输协议）：</strong>基于TCP协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。但FTP是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，若要传输敏感数据，建议使用SFTP（<strong>SSH File Transfer Protocol，安全文件传输协议</strong>）。</li>
<li><strong>Telnet（远程登录协议）：</strong>基于TCP协议，用于通过一个终端登录到其他服务器。但Telnet也是一种不安全的协议，因为所有数据都会以明文的形式传送。</li>
<li><strong>DNS（Domain Name System，域名系统）：</strong>基于UDP协议，用于IP地址与域名映射。</li>
<li><strong>POP3（Post Office Protocol - Version 3，邮局协议版本3）：</strong>基于TCP协议，负责邮件的接收。</li>
<li><strong>IMAP（Internet Mail Access Protocol，邮件访问协议）：</strong>基于TCP协议，负责邮件的接收。相比于POP3协议，IMAP协议支持邮件搜索、标记、分类、归档等功能，并且支持在多个设备之间同步邮件状态。</li>
<li><strong>TCP（Transmission Control Protocol，传输控制协议）：</strong>提供面向连接的、可靠的、有状态的数据传输服务。</li>
<li><strong>UDP（User Datagram Protocol，用户数据报协议）：</strong>提供无连接的，不可靠的，无状态的数据传输服务。</li>
<li><strong>IP（Internet Protocol，网际互联协议）：</strong>主要用来定义数据包格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前IP协议主要有两种，分别为IPv4和IPv6。</li>
<li><strong>ICMP（Internet Control Message Protocol，互联网控制信息协议）：</strong>一种用于传输网络状态和错误信息的协议，常用于网络诊断和故障排除。例如：<code>ping</code>命令就是使用ICMP协议来测试网络连通性。</li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）：</strong>用于解决IP地址与物理地址（MAC地址）相互转化的问题。</li>
<li><strong>RIP（Routing Information Protocol，路由信息协议）：</strong>一种内部网关协议，也是一种动态路由协议。该协议基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
</ul>
<h1 id="三、常见协议端口号"><a href="#三、常见协议端口号" class="headerlink" title="三、常见协议端口号"></a>三、常见协议端口号</h1><ul>
<li>Telnet（远程登录协议）：23</li>
<li>FTP（文件传输协议）：20、21</li>
<li>SMTP（简单邮件传输协议）：25</li>
<li>POP3（邮局协议版本3）：110</li>
<li>DNS（域名系统）：53</li>
<li>SSH（安全外壳协议）：22</li>
<li>HTTP（超文本传输协议）：80</li>
<li>HTTPS（安全的超文本传输协议）：443</li>
</ul>
<h1 id="四、从输入URL到页面展示的全过程"><a href="#四、从输入URL到页面展示的全过程" class="headerlink" title="四、从输入URL到页面展示的全过程"></a>四、从输入URL到页面展示的全过程</h1><ol>
<li><strong>DNS解析：</strong>浏览器查找所输入域名的IP地址。</li>
<li><strong>TCP连接：</strong>浏览器与目标服务器通过“三次握手”建立TCP连接。</li>
<li><strong>发送请求：</strong>浏览器通过HTTP协议发送请求。</li>
<li><strong>返回报文：</strong>服务器处理请求并将处理结果及相应的视图返回给浏览器。</li>
<li><strong>解析、渲染页面：</strong>浏览器解析并渲染页面。若遇到对js、css、图片等静态资源的引用，则重复上述步骤，向服务器请求这些资源。</li>
<li><strong>TCP断开连接：</strong>浏览器与目标服务器通过“四次挥手”断开连接。</li>
</ol>
<h1 id="五、HTTP状态码"><a href="#五、HTTP状态码" class="headerlink" title="五、HTTP状态码"></a>五、HTTP状态码</h1><table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100（Continue）</td>
<td align="center">请求者应当继续发起请求。表示服务器已经收到请求的第一部分，正在等到其余部分。例如：浏览器使用POST方式向服务器发起请求时，要先进行“三次握手”，然后服务器返回100状态码，浏览器才会再次发送数据。</td>
</tr>
<tr>
<td align="center">200（OK）</td>
<td align="center">服务器已经成功处理请求</td>
</tr>
<tr>
<td align="center">201（Created）</td>
<td align="center">请求被成功处理并且在服务端创建了一个新的资源。例如：通过POST请求创建一个新的用户。</td>
</tr>
<tr>
<td align="center">202（Accepted）</td>
<td align="center">服务端已经接收到了请求，但是还没有进行处理。</td>
</tr>
<tr>
<td align="center">204（No Content）</td>
<td align="center">服务端已经成功处理了请求，但是没有返回任何内容。一般用于只关注处理结果是否成功的场景。</td>
</tr>
<tr>
<td align="center">301（Moved Permanently）</td>
<td align="center">永久重定向。例如：网站网址进行了变更。</td>
</tr>
<tr>
<td align="center">302（Moved Temporarily）</td>
<td align="center">暂时重定向。例如：网站的某些资源原本确实存在，但是被暂时移动到其他的URI下。</td>
</tr>
<tr>
<td align="center">400（Bad Request）</td>
<td align="center">发送的HTTP请求存在问题。例如：请求参数不合法、请求方法错误等。</td>
</tr>
<tr>
<td align="center">401（Unauthorized）</td>
<td align="center">未进行认证，但却访问了需要认证之后才能访问的资源。</td>
</tr>
<tr>
<td align="center">403（Forbidden）</td>
<td align="center">拒绝访问。一般用于针对非法请求。</td>
</tr>
<tr>
<td align="center">404（Not Found）</td>
<td align="center">请求的资源在服务端未找到。</td>
</tr>
<tr>
<td align="center">409（Conflict）</td>
<td align="center">请求的资源与服务端当前的状态存在冲突，请求无法被处理。</td>
</tr>
<tr>
<td align="center">410（Gone）</td>
<td align="center">服务器上某个资源被永久性的删除。</td>
</tr>
<tr>
<td align="center">500（Internal Server Error）</td>
<td align="center">服务端内部出错。例如：服务端抛异常，且这个异常没有被处理（异常捕获）。</td>
</tr>
<tr>
<td align="center">502（Bad Gateway）</td>
<td align="center">网关将请求转发到服务端，但服务端返回的是一个错误的响应。</td>
</tr>
</tbody></table>
<h1 id="六、HTTP和HTTPS的区别"><a href="#六、HTTP和HTTPS的区别" class="headerlink" title="六、HTTP和HTTPS的区别"></a>六、HTTP和HTTPS的区别</h1><ul>
<li><strong>端口号不同：</strong>HTTP端口号为80，HTTPS端口号为443。</li>
<li><strong>URL前缀不同：</strong>HTTP的URL前缀是<code>http://</code>，HTTPS的URL前缀是<code>https://</code>。</li>
<li><strong>安全性不同：</strong>HTTP是明文传输，客户端和服务器都无法验证对方的身份，所以安全性很低。而HTTPS是运行在SSL&#x2F;TLS之上的，所有内容都经过加密，加密采用对称加密，而对称加密的秘钥又是采用服务端证书进行了非对称加密，所以安全性很高。不过HTTPS比HTTP更耗费服务器资源。</li>
</ul>
<h1 id="七、HTTP-x2F-1-0和HTTP-x2F-1-1的区别"><a href="#七、HTTP-x2F-1-0和HTTP-x2F-1-1的区别" class="headerlink" title="七、HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别"></a>七、HTTP&#x2F;1.0和HTTP&#x2F;1.1的区别</h1><ul>
<li><p><strong>连接方式：</strong>HTTP1.0默认使用短连接，但可以通过设置请求头的<code>Connection</code>属性为<code>Keep-Alive</code>来实现长连接。HTTP&#x2F;1.1默认使用长连接。实现长连接需要客户端和服务端均支持长连接。</p>
</li>
<li><p><strong>状态码：</strong>HTTP&#x2F;1.0仅定义了16种状态码。而HTTP&#x2F;1.1新加入了大量的状态码。例如：409（Conflict）、410（Gone）、100（Continue）、206（Partial Content）等。</p>
</li>
<li><p><strong>缓存策略：</strong>HTTP&#x2F;1.0中主要使用Header里的<code>If-Modified-Since</code>和<code>Expires</code>作为缓存判断的标准，而HTTP&#x2F;1.1引入了更多的缓存控制策略，例如：<code>Entity tag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code>等。</p>
</li>
<li><p><strong>带宽：</strong>HTTP&#x2F;1.0中存在一些浪费带宽的情况，例如：客户端只需要某个对象的一部分，而服务器却将整个对象都传送过来了，并且不支持断点续传功能。而HTTP&#x2F;1.1引入了范围请求机制，当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，可以在请求中加入<code>range</code>头部，以请求数据的一部分，对应的状态码为206（Partial Content）。此外，HTTP&#x2F;1.1在针对大文件请求时也做了优化，引入了100（Continue）状态码，当服务器不愿意响应这种大文件请求时，100状态码可以作为指示请求是否会被正常响应的标志。过程如下图：</p>
<p><img src="/img/article_content_img/http1.1_continue1.png" alt="http1.1_continue1"></p>
<p><img src="/img/article_content_img/http1.1_continue2.png" alt="http1.1_continue1"></p>
</li>
<li><p><strong>Host域：</strong>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP&#x2F;1.0不支持。例如：有一个资源的URL是<code>http://test1.org/index.html</code>，对于HTTP&#x2F;1.0来说，请求的是<code>GET /index.html</code>，即没有加入主机名。这样的报文送到服务端，服务器无法理解客户端想要请求的真正网址。而对于HTTP&#x2F;1.1来说，请求的是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: test1.org</span><br></pre></td></tr></table></figure>

<p>这样，服务器就知道客户端想请求的真正网址了。</p>
</li>
</ul>
<h1 id="八、HTTP-x2F-1-1和HTTP-x2F-2-0的区别"><a href="#八、HTTP-x2F-1-1和HTTP-x2F-2-0的区别" class="headerlink" title="八、HTTP&#x2F;1.1和HTTP&#x2F;2.0的区别"></a>八、HTTP&#x2F;1.1和HTTP&#x2F;2.0的区别</h1><ul>
<li><strong>IO多路复用：</strong>HTTP&#x2F;1.1使用的是串行方式，每个请求和响应都需要独立的连接。HTTP&#x2F;2.0引入IO多路复用技术，支持在同一个连接上并发处理多个请求，并且并发请求的数量比HTTP&#x2F;1.1大了好几个量级。因此，在处理多个请求时HTTP&#x2F;2.0更加高效，减少了网络延迟，提高了性能。</li>
<li><strong>二进制帧：</strong>HTTP&#x2F;1.1使用文本格式的报文进行数据传输，而HTTP&#x2F;2.0使用二进制帧进行数据传输，二进制帧更加紧凑和高效，减少了传输的数据量和宽带消耗。</li>
<li><strong>头部压缩：</strong>HTTP&#x2F;1.1中，请求和响应都是由自由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩后的二进制文件，但状态行和头部没有经过任何压缩，直接以纯文本的形式传输。随着Web功能越来越复杂，每个页面产生的请求越来越多，导致消耗在头部的流量越来越多，尤其每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。所以在HTTP&#x2F;2.0中采用HPACK算法对头部数据进行压缩，体积小了，传输速度就更快了。</li>
<li><strong>服务器推送：</strong>对于HTTP&#x2F;1.1来说，想要获取任何资源，客户端都必须自己向服务端发送请求，这样就会导致客户端请求次数过多。而HTTP&#x2F;2.0引入了服务器推送技术（Sever Push），它允许服务器推送资源给浏览器，即当客户端请求一个资源时，服务器会将其他相关的资源一并推送给客户端，从而减少了客户端的请求次数和延迟。</li>
</ul>
<h1 id="九、HTTP-x2F-2-0和HTTP-x2F-3-0的区别"><a href="#九、HTTP-x2F-2-0和HTTP-x2F-3-0的区别" class="headerlink" title="九、HTTP&#x2F;2.0和HTTP&#x2F;3.0的区别"></a>九、HTTP&#x2F;2.0和HTTP&#x2F;3.0的区别</h1><ul>
<li><strong>传输协议：</strong>HTTP&#x2F;2.0是基于TCP的协议，HTTP&#x2F;3.0新增了QUIC（Quic UDP Internet Connections）协议来实现可靠的传输，提供与SSL&#x2F;TLS相当的安全性，具有较低的连接和传输延迟。</li>
<li><strong>连接建立：</strong>由于HTTP&#x2F;2.0是基于TCP的协议，因此建立连接需要进行“三次握手”过程（一般是3个RTT）。而HTTP&#x2F;3.0是基于UDP的协议，因此避免了“三次握手”过程，它允许在第一次连接时发送数据（0个RTT）。</li>
<li><strong>队头阻塞：</strong>HTTP&#x2F;2.0采用了IO多路复用，即多个请求复用一个TCP连接，因此一旦发生丢包，就会阻塞所有HTTP请求。而HTTP&#x2F;3.0基于QUIC协议的特性，在一定程度上解决了队头阻塞问题。一个连接建立多个不同的数据流，这些数据流之间互不影响，当某个数据流发生了丢包，其他数据流不会受到影响（本质上是多路复用+轮询）。</li>
<li><strong>错误恢复：</strong>HTTP&#x2F;3.0相比于HTTP&#x2F;2.0来说，具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而HTTP&#x2F;2.0需要依赖于TCP的错误恢复机制。</li>
<li><strong>安全性：</strong>HTTP&#x2F;2.0使用TLS协议进行加密，而HTTP&#x2F;3.0基于QUIC协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li>
</ul>
<h1 id="十、HTTPS（SSL-x2F-TLS）的连接过程是怎么样的"><a href="#十、HTTPS（SSL-x2F-TLS）的连接过程是怎么样的" class="headerlink" title="十、HTTPS（SSL&#x2F;TLS）的连接过程是怎么样的"></a>十、HTTPS（SSL&#x2F;TLS）的连接过程是怎么样的</h1><ol>
<li><p>TLS层是在TCP层之上的，因此在建立TLS之前，需要先建立TCP连接。</p>
</li>
<li><p>客户端向服务器发送建立TLS请求，请求内容包括：客户端支持的SSL&#x2F;TLS协议版本号、客户端产生的随机数client-random、客户端支持的加密规则等。</p>
</li>
<li><p>服务端收到客户端的请求后，向客户端发出响应，响应内容包括：确认SSL&#x2F;TLS协议版本号、服务器产生的随机数server-random、确认的加密规则、服务器的数字证书。</p>
</li>
<li><p>校验数字证书，如果校验失败，连接断开。如果校验成功，则继续步骤5。</p>
</li>
<li><p>如果校验通过，客户端会从数字证书中取出服务器的公钥，然后使用这个公钥去加密要传输的报文，之后向服务器发送以下信息：</p>
<ul>
<li>Client Key Exchange：基于前面提到的两个随机数，再生成第三个随机数pre-master，然后通过CA证书中的公钥对pre-master加密，得到pre-master key，发送给服务器。</li>
<li>Change Cipher Spec：加密通信算法改变通知，表示客户端随后的信息都将用<strong>会话秘钥</strong>加密通信。</li>
<li>Encrypted handshake message：这一步对应的是客户端的Finish消息，客户端将前面握手的消息生成摘要，再用协商好的会话秘钥进行加密，这是客户端发出的第一条加密消息，服务端收到后，会用会话秘钥解密，如果能解出来说明前面协商的秘钥是一致的，至此，客户端的握手完成。</li>
</ul>
<blockquote>
<p>会话秘钥是用双方协商的加密算法和三个随机数生成的</p>
</blockquote>
</li>
<li><p>服务器使用自己的CA证书的私钥对pre-master key解密，得到pre-master，再计算出会话秘钥，随后向客户端发送以下信息：</p>
<ul>
<li>Change Cipher Spec：加密通信算法改变通知，表示服务端随后的信息都将用会话秘钥加密通信。</li>
<li>Encrypted handshake message：这一步对应的是服务端的Finish消息，服务端会将握手过程消息生成摘要，然后再用会话秘钥加密，这是服务器发出的第一条加密消息，客户端接收后会用会话秘钥解密，能解出来说明协商成功。</li>
</ul>
</li>
<li><p>至此，整个SSL&#x2F;TLS的握手阶段全部结束，TCP四次挥手断开连接。</p>
</li>
</ol>
<h1 id="十一、HTTP协议如何保持状态"><a href="#十一、HTTP协议如何保持状态" class="headerlink" title="十一、HTTP协议如何保持状态"></a>十一、HTTP协议如何保持状态</h1><p>HTTP是一种无状态协议，即不会对请求和响应之间的通信状态进行保存。因此，当我们需要保存用户状态时，需要采用Session机制。Session的主要作用就是通过服务端记录用户的状态，典型场景是购物车，当添加商品到购物车时，系统本来是不知道是哪个用户操作的（HTTP无状态），但由于服务端会给每个用户创建特定的Session，以此来标识并跟踪用户，这样系统便知道是哪个用户进行添加购物车的操作了。</p>
<p>Session在服务端一般会保存在数据库和内存（例如：Redis）。然后通过在Cookie中附加SessionID的方式来实现Session跟踪。如果Cookie被禁用了，则可以利用URL重写，把SessionID直接附加到URL路径的后面。</p>
<h1 id="十二、Cookie和Session是如何配合的"><a href="#十二、Cookie和Session是如何配合的" class="headerlink" title="十二、Cookie和Session是如何配合的"></a>十二、Cookie和Session是如何配合的</h1><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session，请求返回时将此Session的唯一标识信息SessionID返回给浏览器，浏览器收到服务器返回的SessionID后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名。</p>
<p>用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务器，服务器会从Cookie中获取SessionID，再根据SessionID查找对应的Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到了，说明用户已经登录，可执行后续操作。</p>
<h1 id="十三、Cookie和Session的区别"><a href="#十三、Cookie和Session的区别" class="headerlink" title="十三、Cookie和Session的区别"></a>十三、Cookie和Session的区别</h1><ul>
<li><strong>存储位置：</strong>Cookie的数据信息保存在客户端浏览器中。Session的数据信息保存在服务器上。</li>
<li><strong>存储容量：</strong>单个Cookie保存的数据小于等于4KB，一个站点最多保存20个Cookie。对于Session来说，没有上限，但是出于对服务器的性能考虑，Session内不要存放过多的东西，并且设置Session删除机制。</li>
<li><strong>存储方式：</strong>Cookie中只能保存ASCII字符串，如果要存储非ASCII字符串还要对其编码。Session中能够存储任何类型的数据。</li>
<li><strong>隐私策略：</strong>Cookie存储在浏览器中，对客户端是可见的。Session存储在服务器上，对客户端是透明的（不可见）。</li>
<li><strong>跨域支持：</strong>Cookie支持跨域名访问，Session不支持跨域名访问。</li>
<li><strong>生命周期：</strong>Cookie保存在硬盘中，通过设置<code>maxAge</code>属性来设置生命周期，如果是比较大的正整数，那么关闭浏览器，Cookie还是存在的。Session保存在服务器中，设置<code>maxInactiveInterval</code>属性值来确定Session的有效期，并且Session虽然没有从服务器中消亡，但也失效了。</li>
<li><strong>浏览器支持：</strong>如果浏览器禁用了Cookie，那么Cookie是无用的。而Session可以通过url重写来进行会话跟踪。</li>
</ul>
<h1 id="十四、HTTP的GET和POST请求方式的区别"><a href="#十四、HTTP的GET和POST请求方式的区别" class="headerlink" title="十四、HTTP的GET和POST请求方式的区别"></a>十四、HTTP的GET和POST请求方式的区别</h1><ul>
<li>GET是获取数据，POST是提交数据。</li>
<li>我们平时在浏览器上输入网址直接访问的方式就是GET方式。而form表单提交，method里面设置的post，则是POST方式。</li>
<li>GET的访问时候的参数是在URL里面的，比如<code>?username=111&amp;password=123</code>，POST提交的参数是在请求体里面的。而且在请求体里面的会进行urlencode编码，所以这两者相比较来说，POST更安全。但其实从数据传输角度来说这两种都不安全，如果想要安全的，需要使用HTTPS协议。</li>
<li>GET有浏览器缓存记录，而POST没有。</li>
<li>GET方式访问的URL是可以保存为浏览器书签的，POST不可以。</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET请求的URL的编码格式采用的是ASCII编码，而不是unicode，所以所有的非ASCII字符都要编码之后再传输。</li>
<li>GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li>
<li>GET只能传输ASCLL字符，不能进行编码。POST传输的时候是放在HTTP的请求体之中的，并且是经过urlencode编码的所以是相对安全的。POST对数据类型没有限制限制，二进制数据也是可以的。</li>
<li>HTTP协议并没有对GET和POST的长度做限制，其实是浏览器限制了他们传输大小。URL地址是有长度限制的，浏览器不同，长度限制的具体数值也是不一样的。比如IE浏览器是2083字节。需要注意的是这些仅仅是URL地址栏的长度限制。理论上来说POST的长度是没有限制的，但是受服务器的配置限制或者内存大小的限制，造成了实际开发中POST也是有数据长度的限制的。</li>
<li>因为GET是获取数据，所以GET请求是安全且幂等的，是无害的。这个安全指得是对数据不会造成影响。幂等就是无论获取多少次数据得到的资源都是一样的。POST是向服务器传输数据，数据会被重新提交，所以就会有对原有的数据造成伤害。</li>
</ul>
<h1 id="十五、URL和URI的区别"><a href="#十五、URL和URI的区别" class="headerlink" title="十五、URL和URI的区别"></a>十五、URL和URI的区别</h1><p>URI是统一资源标识符，可以唯一标识一个资源。</p>
<p>URL是统一资源定位符，它是具体的URI，即它既可以唯一标识一个资源，还提供了定位该资源的信息。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题记录（链表）</title>
    <url>/2023/06/16/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h1><h2 id="1、合并两个有序链表"><a href="#1、合并两个有序链表" class="headerlink" title="1、合并两个有序链表"></a>1、合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code>和一个当前指针<code>cur</code>，<code>cur</code>指向<code>virtualNode</code>。</li>
<li>两个链表同时遍历，当<code>list1.val</code>小于等于<code>list2.val</code>的时候，创建一个新结点，值为<code>list1.val</code>，插入到新链表中。</li>
<li>当两个链表中只要有一个链表遍历完时，结束循环。未遍历完的链表直接插到新链表中即可。</li>
<li>最终返回<code>virtualNode.next</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个单链表：</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     // 声明节点的值为val</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 声明节点的下一个节点为next</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 无参构造、含有val参数的有参构造、含有val、next参数的有参构造</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、删除排序链表中的重复元素"><a href="#2、删除排序链表中的重复元素" class="headerlink" title="2、删除排序链表中的重复元素"></a>2、删除排序链表中的重复元素</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></p>
<p>思路：</p>
<ul>
<li>定义一个当前指针<code>cur</code>指向头结点</li>
<li>如果链表不存在（<code>cur== null</code>）或者链表只有一个结点（<code>cur.next == null</code>），直接返回头结点<code>head</code>。</li>
<li>否则，判断<code>cur</code>指向的当前结点的值与下一个结点的值是否相等。若相等，说明下一个结点是重复结点，则删除下一个结点（断链：<code>cur.next = cur.next.next</code>）；若不相等，说明不是重复结点，当前指针<code>cur</code>右移。</li>
<li>所有结点都遍历完后（此时当前指针<code>cur</code>要么为<code>null</code>了，要么<code>cur.next</code>为<code>null</code>了），直接返回头结点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、判断链表是否有环"><a href="#3、判断链表是否有环" class="headerlink" title="3、判断链表是否有环"></a>3、判断链表是否有环</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
<p>思路：</p>
<ul>
<li>使用快慢指针（<code>fast</code>、<code>slow</code>）。</li>
<li>初始时刻，快、慢指针均指向头结点<code>head</code>。</li>
<li><code>fast  != null</code>并且<code>fast.next != null</code>，就一直循环遍历该链表。快指针每次走两步，慢指针每次走一步。</li>
<li>如果快指针跟慢指针碰上了（<code>slow == fast</code>），那说明链表是有环的，返回<code>true</code>。如果整个链表遍历完了，快慢指针也没碰上，说明无环，返回<code>false</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slowNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fastNode != <span class="literal">null</span> &amp;&amp; fastNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            fastNode = fastNode.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fastNode == slowNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、相交链表"><a href="#4、相交链表" class="headerlink" title="4、相交链表"></a>4、相交链表</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
<p>思路：</p>
<ul>
<li>两个链表中，只要有一个是空的（<code>null</code>），则不可能相交，直接返回<code>null</code>。</li>
<li>定义两个当前指针<code>curA</code>和<code>curB</code>，分别指向<code>headA</code>和<code>headB</code>。</li>
<li><code>curA</code>和<code>curB</code>同时向前走，当其中一个指针走到链表的末尾，例如<code>curA==null</code>，此时让<code>curA</code>指向另外一个链表的头结点。（<code>curA.next = headB</code>）。对<code>curB</code>采取同样的操作。之后两个指针继续同步向前走。</li>
<li>当<code>curA</code>和<code>curB</code>相遇时，就是两个链表相交时的结点。返回<code>curA</code>或者<code>curB</code>均可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">            curA = curA != <span class="literal">null</span> ? curA.next : headB;</span><br><span class="line">            curB = curB != <span class="literal">null</span> ? curB.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、移除链表元素"><a href="#5、移除链表元素" class="headerlink" title="5、移除链表元素"></a>5、移除链表元素</h2><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code> ，并让<code>virtualNode.next = head</code>。定义一个当前指针<code>cur</code>指向head头结点。</li>
<li>声明一个前置指针<code>pre</code>，指向<code> virtualNode</code> ，用来临时存储当前指针<code>cur</code>的前一个结点。</li>
<li>使用cur指针遍历当前链表，若当前遍历到的结点的值与指定的value值相同，则删除该结点（<code>pre.next = cur.next</code>），然后<code>cur</code>指针向前走一步，继续完成遍历。否则，继续向前遍历结点，<code>cur</code>与<code>pre</code>指针同时向前走一步。</li>
<li>当<code>cur</code>为<code>null</code>时，说明链表遍历完毕，返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != val) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、反转链表"><a href="#6、反转链表" class="headerlink" title="6、反转链表"></a>6、反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>迭代：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                直到当前节点的下一个节点为空时返回当前节点</span></span><br><span class="line"><span class="comment">                由于5没有下一个节点了，所以此处返回节点5</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归传入下一个节点，目的是为了到达最后一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮出栈，head为5，head.next为空，返回5</span></span><br><span class="line"><span class="comment">            第二轮出栈，head为4，head.next为5，执行head.next.next=head也就是5.next=4，</span></span><br><span class="line"><span class="comment">                      把当前节点的子节点的子节点指向当前节点</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-&gt;5，由于4与5互相指向，所以此处要断开4.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3-&gt;4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第三轮出栈，head为3，head.next为4，执行head.next.next=head也就是4.next=3，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-&gt;4&lt;-5，由于3与4互相指向，所以此处要断开3.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2-&gt;3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第四轮出栈，head为2，head.next为3，执行head.next.next=head也就是3.next=2，</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-&gt;3&lt;-4&lt;-5，由于2与3互相指向，所以此处要断开2.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1-&gt;2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            第五轮出栈，head为1，head.next为2，执行head.next.next=head也就是2.next=1，</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-&gt;2&lt;-3&lt;-4&lt;-5，由于1与2互相指向，所以此处要断开1.next=null</span></span><br><span class="line"><span class="comment">                      此时链表为1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="comment">                      返回节点5</span></span><br><span class="line"><span class="comment">            出栈完成，最终头节点5-&gt;4-&gt;3-&gt;2-&gt;1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、回文链表"><a href="#7、回文链表" class="headerlink" title="7、回文链表"></a>7、回文链表</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
<p>思路：</p>
<ul>
<li>首先使用快慢指针，找到链表的中间结点。假设链表结点个数是K，若K为奇数，则中间结点为K&#x2F;2+1；若K为偶数，则中间结点为K&#x2F;2。（例：K&#x3D;5，那么5&#x2F;2+1&#x3D;3，中间结点是第三个结点）</li>
<li>从中间结点进行断链，左边是前半部分，右边是后半部分。（中间结点属于前半部分！！！）</li>
<li>对原链表的后半部分进行反转。</li>
<li>对原链表的前半部分与原链表后半部分反转之后的链表进行同步遍历，若值不相等，则不是回文链表，反之是回文链表。（由于原链表的后半部分长度一定小于等于前半部分，因此在遍历时，循环结束条件是指向原链表后半部分的指针为<code>null</code>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">endOfFrontHalfPartList</span> <span class="operator">=</span> getEndFrontHalfPartList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedNode</span> <span class="operator">=</span> reverseNode(endOfFrontHalfPartList.next);</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> reversedNode;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isHuiWen</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isHuiWen &amp;&amp; p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                isHuiWen = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isHuiWen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getEndFrontHalfPartList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、链表的中间节点"><a href="#8、链表的中间节点" class="headerlink" title="8、链表的中间节点"></a>8、链表的中间节点</h2><p><a href="https://leetcode.cn/problems/middle-of-the-linked-list">https://leetcode.cn/problems/middle-of-the-linked-list</a></p>
<p>思路：</p>
<ul>
<li>快慢指针。初始时刻，快慢指针均指向头结点。之后快指针每次走两步，慢指针每次走一步。当快指针走到<code>null</code>或者快指针的下一个结点为<code>null</code>了，此时慢指针指向的结点就是链表的中间结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、二进制链表转整数"><a href="#9、二进制链表转整数" class="headerlink" title="9、二进制链表转整数"></a>9、二进制链表转整数</h2><p><a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer">https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer</a></p>
<p>思路：</p>
<ul>
<li>考虑到链表从左向右，指数是递减的。因此进行反转链表。</li>
<li>声明变量<code>k</code>，代表2的指数幂，每遍历一个结点，<code>k++</code>。</li>
<li>声明变量<code>sum</code>用来统计结果。<code>sum = sum += cur.val * Math.pow(2, k)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDecimalValue</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedNode</span> <span class="operator">=</span> reverse(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reversedNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            result += cur.val * Math.pow(<span class="number">2</span>, k);</span><br><span class="line">            k++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、从尾到头打印链表"><a href="#10、从尾到头打印链表" class="headerlink" title="10、从尾到头打印链表"></a>10、从尾到头打印链表</h2><p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
<p>思路1：</p>
<p>反转链表+遍历链表打印输出</p>
<p>思路2：</p>
<p>栈是先进后出的，因此可以考虑先将链表中每一个节点入栈，再弹栈。每弹出一个结点，数组存储一个值。栈的实现可以使用LinkedList或者ArrayDeque（推荐：性能好）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.addFirst(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、返回链表中倒数第K个节点"><a href="#11、返回链表中倒数第K个节点" class="headerlink" title="11、返回链表中倒数第K个节点"></a>11、返回链表中倒数第K个节点</h2><p>思路：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
<p>快慢指针。快指针先走K步。之后快慢指针同步走，当快指针指向<code>null</code>时，慢指针指向的结点就是倒数第K个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、移除重复节点"><a href="#12、移除重复节点" class="headerlink" title="12、移除重复节点"></a>12、移除重复节点</h2><p><a href="https://leetcode.cn/problems/remove-duplicate-node-lcci">https://leetcode.cn/problems/remove-duplicate-node-lcci</a></p>
<p>思路：</p>
<ul>
<li>HashSet里面存储的元素是不可重复的，因此考虑是用HashSet。</li>
<li>定义一个前驱指针<code>pre</code>，用来记录遍历到的当前结点的前一个结点，以便删除结点时使用。</li>
<li>遍历链表，如果set中不存在，就把结点的值存进set中。</li>
<li>如果set中存在，则删除该结点。<code>pre.next = cur.next</code>。</li>
<li>最后返回头结点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeDuplicateNodes</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(cur.val)) &#123;</span><br><span class="line">                set.add(cur.val);</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><h2 id="1、删除链表倒数第N个节点"><a href="#1、删除链表倒数第N个节点" class="headerlink" title="1、删除链表倒数第N个节点"></a>1、删除链表倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">https://leetcode.cn/problems/remove-nth-node-from-end-of-list</a></p>
<p>思路：</p>
<ul>
<li>因为删除一个结点需要使用到该结点的前一个结点指针。因此，先声明一个虚拟头结点<code>virtualNode</code> ，并定义一个前驱指针<code>pre</code>，让<code>pre</code>指针指向该虚拟头结点。</li>
<li>定义快慢指针<code>slow</code>、<code>fast</code>，快指针<code>fast</code>先走<code>n</code>步，之后<code>pre</code>、<code>slow</code>和<code>fast</code>三个指针同步向前走，当<code>fast</code>为<code>null</code>时，<code>slow</code>所指向的结点即为倒数第N个结点。</li>
<li>有前驱指针<code>pre</code>，即可完成链表的删除操作。<code>pre.next = slow.next</code></li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h2><p><a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头结点<code>virtualNode</code>，并声明一个当前指针<code>cur</code>指向<code>virtualNode</code>。</li>
<li>由于两数相加可能会产生进位，所以定义一个变量<code>jinwei</code>记录进位值。</li>
<li>两数之和除以10，得到十位的值，即进位值（因为两个小于10的数相加，进位要么是0，要么是1）。两数之和对10取余得到个位数（例如：12&#x2F;10&#x3D;1，12%10&#x3D;2。7&#x2F;10&#x3D;0，7%10&#x3D;7）。这里需要注意的是，两数相加之后，还需要加上进位值，且当某一个链表遍历到末尾，即为null时，值指定为0。</li>
<li>当两个链表都遍历结束后，还需要再判断一下是否存在进位值，若存在，则需要再插入一个结点，值为进位值。</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jinwei</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val) +  (l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val) + jinwei;</span><br><span class="line">            jinwei = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jinwei &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(jinwei);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、两两交换链表中的节点"><a href="#3、两两交换链表中的节点" class="headerlink" title="3、两两交换链表中的节点"></a>3、两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>思路：</p>
<ul>
<li>定义一个虚拟头节点<code>virtualNode</code>，并定义一个<code>tmp</code>指针指向<code>virtualNode</code>（需要交换的两个节点中第一个节点的前一个节点）。</li>
<li>每两个节点进行交换，定义一个<code>start</code>指针指向这两个节点中的第一个节点，定义一个<code>end</code>指针指向这两个节点中的第二个节点。初始为：<code>start = tmp.next</code> 和 <code>end = tmp.next.next</code>。</li>
<li>改变指针的指向，使两个节点进行交换。交换完后再让<code>tmp</code>指针指向<code>start</code>即可。（交换之后，start就指向交换过后的两个节点中的后面那个节点，也就是下一组需要交换的两个节点的第一个节点的前一个节点）</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="literal">null</span> &amp;&amp; tmp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> tmp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> tmp.next.next;</span><br><span class="line">            tmp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            tmp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、旋转链表"><a href="#4、旋转链表" class="headerlink" title="4、旋转链表"></a>4、旋转链表</h2><p><a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></p>
<p>思路：</p>
<ul>
<li>若链表长度为<code>n</code>，则让快指针<code>fast</code>先走<code>k % n</code>步，之后快慢指针一起走。</li>
<li>当<code>fast.next==null</code>时，<code>slow</code>指向的就是新链表的尾结点，<code>slow.next</code>指向的节点就是新的头结点<code>newHead</code>。</li>
<li>所以此时让<code>slow.next==null</code>，进行断链。之后让<code>fast</code>指向<code>head</code>，组成新链表。最后返回<code>newHead</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> k % num;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        fast.next = head;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、删除链表中的重复元素Ⅱ"><a href="#5、删除链表中的重复元素Ⅱ" class="headerlink" title="5、删除链表中的重复元素Ⅱ"></a>5、删除链表中的重复元素Ⅱ</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii</a></p>
<p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字。返回 已排序的链表。</p>
<p><img src="/img/article_content_img/image-20230425215955324.png" alt="image-20230425215955324"></p>
<p>思路：</p>
<ul>
<li>由于链表是有序的，所以相同的节点肯定是紧挨着的。</li>
<li>由于链表的头节点可能会被删除，因此我们需要额外使用一个虚拟头节点（<code>virtualNode</code>）指向链表的头节点。</li>
<li>定义一个指针<code>cur</code>去遍历链表，初始时，<code>cur</code>指向<code>virtualNode</code>。当<code>cur.next</code>与<code>cur.next.next</code>所指向的元素值相同时，记下这个值为<code>x</code>，之后就需要将<code>cur.next</code>及其后面所有值等于<code>x</code>的节点都删除。当<code>cur.next</code>与<code>cur.next.next</code>所指向的元素值不同时，说明该元素只出现了一次，所以<code>cur = cur.next</code>。</li>
<li>需要注意的是，cur.next有可能是个空节点，因此，判断的时候需要加上<code>cur.next != null</code>。</li>
<li>最后返回<code>virtualNode.next</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、分隔链表"><a href="#6、分隔链表" class="headerlink" title="6、分隔链表"></a>6、分隔链表</h2><p><a href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<p>思路：</p>
<ul>
<li>分别定义两个链表，一个<code>smallList</code>，一个<code>largeList</code>。<code>smallList</code>上节点的值都是小于<code>x</code>的。<code>largeList</code>上节点的值都是大于<code>x</code>的。</li>
<li>定义一个<code>cur</code>指针去遍历给定链表。如果当前节点的值小于<code>x</code>，就往<code>smallList</code>上插入一个新节点。反之，往<code>largeList</code>上插入一个新节点。节点的值都为<code>cur.val</code>。</li>
<li>最后把<code>largeList</code>链接到<code>smallList</code>的后面，并返回<code>smallList</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smallCur</span> <span class="operator">=</span> smallList;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">largeCur</span> <span class="operator">=</span> largeList;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &lt; x) &#123;</span><br><span class="line">                smallCur.next = cur;</span><br><span class="line">                smallCur = smallCur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largeCur.next = cur;</span><br><span class="line">                largeCur = largeCur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        largeCur.next = <span class="literal">null</span>;</span><br><span class="line">        smallCur.next = largeList.next;</span><br><span class="line">        <span class="keyword">return</span> smallList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、反转链表2"><a href="#7、反转链表2" class="headerlink" title="7、反转链表2"></a>7、反转链表2</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>思路：</p>
<ul>
<li>因为可能会存在从第一个结点到某个结点进行反转的情况，因此需要建立一个虚拟头结点<code>virtualNode</code>。</li>
<li>定义一个<code>pre</code>指针，初始在虚拟头结点处，记录需要反转的链表的头结点的前一个结点。</li>
<li>使用快慢指针，<code>fast</code>指针走到right处，<code>slow</code>指针走到left处（<code>pre</code>指针随着<code>slow</code>指针一起走）。定义一个<code>tmpHead</code>指针指向<code>fast</code>的下一个结点。此时，<code>slow</code>到<code>fast</code>这个区间的结点就是需要反转的链表。</li>
<li>断开<code>slow</code>到<code>fast</code>这个区间前后的链接，然后对其进行普通反转链表操作。</li>
<li>反转链表操作得到的是反转之后的头结点，因此<code>pre.next</code>操作将其与之前的链表接上。</li>
<li>声明一个<code>cur</code>指针遍历反转之后的链表，找到最后一个结点，然后与<code>tmpHead</code>接上即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; left) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpHead</span> <span class="operator">=</span> fast.next;</span><br><span class="line">        fast.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reversedList</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reversedList;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = reversedList;</span><br><span class="line">        cur.next = tmpHead;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、有序链表转换二叉搜索树"><a href="#8、有序链表转换二叉搜索树" class="headerlink" title="8、有序链表转换二叉搜索树"></a>8、有序链表转换二叉搜索树</h2><p><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/</a></p>
<p>思路一：</p>
<ul>
<li>首先初始链表上节点的值是递增的，而且又要保证生成的二叉树是平衡的（对任意一个节点的左右两个子树的高度差不超过1），所以考虑每次从链表的中间节点取值，作为树的根节点。</li>
<li>采用双指针找到链表的中间节点，之后就创建一个新节点，值为中间节点的值。之后递归地去找当前中间节点左边那一部分的中间节点（生成左子树），递归地去找当前节点右边那一部分的中间节点（生成右子树）。</li>
<li>最后返回生成的二叉树的根节点即可。</li>
<li>双指针找中间节点：<ol>
<li>定义快指针<code>fast</code>与慢指针<code>slow</code>，以及前驱指针<code>pre</code>。</li>
<li><code>fast</code>指针每次走两步，<code>slow</code>与<code>pre</code>指针每次走一步。</li>
<li>当<code>fast == null</code>或者<code>fast.next == null</code>时，此时<code>slow</code>指针所指的位置就是中间节点的位置。</li>
<li>让<code>pre.next = null</code>进行断链，此时，<code>head</code>到<code>pre</code>就是中间节点的前半部分，<code>slow.next</code>到末尾就是中间节点的后半部分。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(slow.val);</span><br><span class="line">        node.left = sortedListToBST(head);</span><br><span class="line">        node.right = sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：</p>
<ul>
<li>使用一个List集合先将链表上节点的值存储起来。</li>
<li>然后找中间节点使用二分法，即<code>mid = left + (right - left) / 2</code>。后续步骤与思路一类似。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertToBST(list, <span class="number">0</span>, list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertToBST</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(list.get(mid));</span><br><span class="line">        root.left = convertToBST(list, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = convertToBST(list, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、将二叉树展开为链表"><a href="#9、将二叉树展开为链表" class="headerlink" title="9、将二叉树展开为链表"></a>9、将二叉树展开为链表</h2><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list</a></p>
<p>思路：</p>
<p><img src="/img/article_content_img/image-20230425181116678.png" alt="image-20230425181116678"></p>
<p>其实是分为三步：</p>
<ul>
<li>首先将根节点的左子树变成链表</li>
<li>其次将根节点的右子树变成链表</li>
<li>最后将变成链表的右子树放在变成链表的左子树的最右边</li>
</ul>
<p>这就是一个递归的过程，递归的一个非常重要的点就是：<strong>不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出。</strong>对于函数flatten来说：</p>
<ul>
<li>函数作用：将一个二叉树，原地将它展开为链表</li>
<li>输入：树的根节点</li>
<li>输出：无</li>
</ul>
<p>那我们就直接根据三步来写程序就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将根节点的左子树变成链表</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        <span class="comment">//将根节点的右子树变成链表</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        <span class="comment">//因为需要将左子树拼到根节点的右边，所以先使用temp临时存储一下右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="comment">//把树的右边换成左边的链表</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        <span class="comment">//记得要将左边置空</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//找到树的最右边的节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">null</span>) root = root.right;</span><br><span class="line">        <span class="comment">//把右边的链表接到刚才树的最右边的节点</span></span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、复制带随机指针的链表"><a href="#10、复制带随机指针的链表" class="headerlink" title="10、复制带随机指针的链表"></a>10、复制带随机指针的链表</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
<p>思路：</p>
<p><img src="/img/article_content_img/image-20230425191755847.png" alt="image-20230425191755847"></p>
<ul>
<li>使用HashMap，key为原节点，value是复制的新节点（创建的新节点）</li>
<li>共有两次对原链表的遍历。第一次遍历，创建新节点，并将原节点与新节点存入HashMap中。第二次遍历，添加新节点之间的指针指向关系。</li>
</ul>
<p><img src="/img/article_content_img/image-20230425191931161.png" alt="image-20230425191931161"></p>
<ul>
<li>从图中可以看出原节点和新节点是一一对应的关系，<code>newNode</code>为新结点，<code>cur</code>为原结点，则：<ul>
<li><code>newNode = map.get(cur)</code></li>
<li><code>newNode.next = map.get(cur.next)</code></li>
<li><code>newNode.random = map.get(cur.random)</code></li>
</ul>
</li>
<li>最后返回新结点的头结点，即<code>map.get(head)</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">            map.put(cur, newNode);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> map.get(cur);</span><br><span class="line">            <span class="comment">// 如果cur有next，才复制</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                newNode.next = map.get(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果cur有random，才复制</span></span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="literal">null</span>) &#123;</span><br><span class="line">                newNode.random = map.get(cur.random);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、环形链表2"><a href="#11、环形链表2" class="headerlink" title="11、环形链表2"></a>11、环形链表2</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<p>返回第一个入环节点，若无环，返回null。</p>
<p>思路：</p>
<ul>
<li>快慢指针：快指针每次走两步，慢指针每次走一步。</li>
<li>当慢指针跟快指针第一次碰面时，让快指针重新指向头节点。</li>
<li>之后快指针与慢指针每次均走一步。若第二次碰面，则碰面时的那个节点就是入环节点。</li>
<li>需要注意的是，因为在第一次碰面前，快指针走的比慢指针快，所以如果链表是无环的，那么快指针一定会先走到<code>null</code>处，或者快指针的下一个节点是<code>null</code>。那么此时直接返回<code>null</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意此处！！！！</span></span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、重排链表"><a href="#12、重排链表" class="headerlink" title="12、重排链表"></a>12、重排链表</h2><p><a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a></p>
<p>1 –&gt; 2 –&gt; 3- -&gt; 4 –&gt; 5 –&gt; 6      &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&gt;  1 –&gt; 6 –&gt; 2 –&gt; 5 –&gt; 3 –&gt; 4</p>
<p>1 –&gt; 2 –&gt; 3     &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D; &#x3D;&gt;  1 –&gt; 3 –&gt; 2 </p>
<p>思路：</p>
<ul>
<li>通过快慢指针找到中间节点，然后断链。</li>
<li>对后面的链表进行反转。</li>
<li>将前面的链表与反转之后的链表进行拼接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(tmpNode);</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> newHead.next;</span><br><span class="line">            newHead.next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            head = newHead.next;</span><br><span class="line">            newHead = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13、LRU缓存"><a href="#13、LRU缓存" class="headerlink" title="13、LRU缓存"></a>13、LRU缓存</h2><p><a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
<p>思路：理解的背下来就行。很简单！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span> <span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span> <span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;</span><br><span class="line">            key = _key;</span><br><span class="line">            value = _value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNodeToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addNodeToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addNodeToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                cache.remove(res.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、对链表进行插入排序"><a href="#14、对链表进行插入排序" class="headerlink" title="14、对链表进行插入排序"></a>14、对链表进行插入排序</h2><p><a href="https://leetcode.cn/problems/insertion-sort-list/">https://leetcode.cn/problems/insertion-sort-list/</a></p>
<p>思路：</p>
<p>+ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastOrderNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> lastOrderNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastOrderNode.val &lt;= cur.val) &#123;</span><br><span class="line">                lastOrderNode = lastOrderNode.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">                <span class="keyword">while</span> (pre.next.val &lt; cur.val) &#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                lastOrderNode.next = cur.next;</span><br><span class="line">                cur.next = pre.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = lastOrderNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、排序链表"><a href="#15、排序链表" class="headerlink" title="15、排序链表"></a>15、排序链表</h2><p><a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<p>思路：</p>
<ul>
<li>分割cut环节：找到当前链表中点，并从中点将链表断开（以便在下次递归cut时，链表片段拥有正确边界）<ul>
<li>我们使用<code>fast</code>，<code>slow</code>快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</li>
<li>找到中点<code>slow</code>后，执行<code>slow.next = null</code>将链表切断。</li>
<li>递归分割时，输入当前链表左端点<code>head</code>和中心节点<code>slow</code>的下一个节点<code>tmp</code>（因为链表是从<code>slow</code>切断的）。</li>
<li>cut递归终止条件：当<code>head.next == null</code>时，说明只有一个节点了，直接返回此节点。</li>
</ul>
</li>
<li>合并 merge 环节：将两个排序链表合并，转化为一个排序链表。<ul>
<li>双指针法合并，建立辅助<code>ListNode h</code>作为头部。</li>
<li>设置两指针<code>left</code>，<code>right</code>分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助<code>ListNode h</code>作为头部的下个节点<code>h.next</code>。</li>
<li>时间复杂度<code>O(l + r)</code>，<code>l</code>，<code>r</code> 分别代表两个链表长度。</li>
</ul>
</li>
<li>当题目输入的<code>head == null</code>时，直接返回<code>null</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(tmp);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                h.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、奇偶链表"><a href="#16、奇偶链表" class="headerlink" title="16、奇偶链表"></a>16、奇偶链表</h2><p><a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></p>
<p>思路：</p>
<ul>
<li>第一个节点是奇数结点，第二个节点是偶数节点，以此类推。</li>
<li>将原链表拆分成两个链表，即一个奇数链表，一个偶数链表。</li>
<li>因为head可以作为奇数链表的头节点，而且head也是最终结果链表的头节点，因此只需要定义一个偶数链表的头节点（<code>evenHead</code>），初始化为<code>head</code>的下一个节点。（因为<code>head</code>的下一个节点一定是偶数节点）</li>
<li>声明一个奇数链表遍历指针<code>oddCur</code>和偶数链表遍历指针<code>evenCur</code>。</li>
<li>因为偶数链表遍历指针在前，所以要保证<code>evenCur != null</code> &amp;&amp; <code>evenCur.next != null</code>。</li>
<li>然后断链重连，将奇数节点与奇数节点连接，偶数节点与偶数节点连接。</li>
<li>最后将奇数链表的尾与偶数链表的头接上，并返回结果链表的头节点<code>head</code>即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> evenHead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17、合并零之间的节点"><a href="#17、合并零之间的节点" class="headerlink" title="17、合并零之间的节点"></a>17、合并零之间的节点</h2><p><a href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">https://leetcode.cn/problems/merge-nodes-in-between-zeros/</a></p>
<p>思路：</p>
<ul>
<li>由于链表的开端和结尾都是0，所以可以直接跳过，从第二个节点开始遍历。因此遍历指针<code>cur=head.next</code>。</li>
<li>用一个变量<code>sum</code>记录两个0之间的节点的值之和。</li>
<li>遍历节点，如果节点的值不为0，则累加到<code>sum</code>中。如果为0，则再新的链表上插入一个新节点，节点的值为<code>sum</code>。之后将<code>sum</code>清零，然后跳过该节点，继续遍历下一个节点。</li>
<li>最后返回新链表即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeNodes</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += cur.val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h1><h2 id="1、实现LFU缓存"><a href="#1、实现LFU缓存" class="headerlink" title="1、实现LFU缓存"></a>1、实现LFU缓存</h2><p><a href="https://leetcode.cn/problems/lfu-cache/">https://leetcode.cn/problems/lfu-cache/</a></p>
<p>思路：理解的背下来就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wyd.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wyd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/05/24/20:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  LFU缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表的前继Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表的后继Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node post;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node所在频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList doublyLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表表示的频次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的前继链表（pre.freq &lt;-- this.freq）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的后继链表 (post.freq --&gt; this.freq)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList post;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的头节点，新节点从头部加入，表示最近访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该双向链表的尾节点，删除节点从尾部删除，表示最久访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">(<span class="type">int</span> freq)</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.post = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        <span class="built_in">this</span>.freq = freq;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.pre.post = node.post;</span><br><span class="line">        node.post.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.post = head.post;</span><br><span class="line">        head.post.pre = node;</span><br><span class="line">        head.post = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.doublyLinkedList = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LfuCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储缓存的内容。</span></span><br><span class="line"><span class="comment">     * Node中包括key、value、freq、所在doublyLinkedList、所在doublyLinkedList中的nextNode、所在doublyLinkedList中的preNode。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer, Node&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * firstLinkedList.post 是频次最大的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList firstLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lastLinkedList.pre 是频次最小的双向链表，满了之后删除 lastLinkedList.pre.tail.pre 这个Node即为频次最小且访问最早的Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DoublyLinkedList lastLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LfuCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line"></span><br><span class="line">        firstLinkedList = <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        lastLinkedList = <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line"></span><br><span class="line">        firstLinkedList.post = lastLinkedList;</span><br><span class="line"></span><br><span class="line">        lastLinkedList.pre = firstLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该key访问频次+1</span></span><br><span class="line"></span><br><span class="line">        freqInc(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若key存在，则更新value，访问频次+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">            freqInc(node);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若key不存在</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果缓存满了，删除lastLinkedList.pre这个链表（即表示最小频次的链表）中的tail.pre这个Node（即最小频次链表中最先访问的Node），如果该链表中的元素删空了，则删掉该链表。</span></span><br><span class="line"></span><br><span class="line">                cache.remove(lastLinkedList.pre.tail.pre.key);</span><br><span class="line"></span><br><span class="line">                lastLinkedList.removeNode(lastLinkedList.pre.tail.pre);</span><br><span class="line"></span><br><span class="line">                size--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lastLinkedList.pre.head.post == lastLinkedList.pre.tail) &#123;</span><br><span class="line"></span><br><span class="line">                    removeDoublyLinkedList(lastLinkedList.pre);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cache中put新Key-Node对儿，并将新node加入表示freq为1的DoublyLinkedList中，若不存在freq为1的DoublyLinkedList则新建。</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lastLinkedList.pre.freq != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">DoublyLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>(<span class="number">1</span>);</span><br><span class="line">                addDoublyLinkedList(newDoublyLinedList, lastLinkedList.pre);</span><br><span class="line">                newDoublyLinedList.addNode(newNode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastLinkedList.pre.addNode(newNode);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * node的访问频次 + 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">freqInc</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node从原freq对应的双向链表里移除, 如果链表空了则删除链表。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">DoublyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> node.doublyLinkedList;</span><br><span class="line"></span><br><span class="line">        <span class="type">DoublyLinkedList</span> <span class="variable">preLinkedList</span> <span class="operator">=</span> linkedList.pre;</span><br><span class="line"></span><br><span class="line">        linkedList.removeNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (linkedList.head.post == linkedList.tail) &#123;</span><br><span class="line"></span><br><span class="line">            removeDoublyLinkedList(linkedList);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将node加入新freq对应的双向链表，若该链表不存在，则先创建该链表。</span></span><br><span class="line"></span><br><span class="line">        node.freq++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLinkedList.freq != node.freq) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">DoublyLinkedList</span> <span class="variable">newDoublyLinedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>(node.freq);</span><br><span class="line"></span><br><span class="line">            addDoublyLinkedList(newDoublyLinedList, preLinkedList);</span><br><span class="line"></span><br><span class="line">            newDoublyLinedList.addNode(node);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            preLinkedList.addNode(node);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addDoublyLinkedList</span><span class="params">(DoublyLinkedList newDoublyLinedList, DoublyLinkedList preLinkedList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.post = preLinkedList.post;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.post.pre = newDoublyLinedList;</span><br><span class="line"></span><br><span class="line">        newDoublyLinedList.pre = preLinkedList;</span><br><span class="line"></span><br><span class="line">        preLinkedList.post = newDoublyLinedList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除代表某1频次的双向链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeDoublyLinkedList</span><span class="params">(DoublyLinkedList doublyLinkedList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        doublyLinkedList.pre.post = doublyLinkedList.post;</span><br><span class="line"></span><br><span class="line">        doublyLinkedList.post.pre = doublyLinkedList.pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、合并K个升序链表"><a href="#2、合并K个升序链表" class="headerlink" title="2、合并K个升序链表"></a>2、合并K个升序链表</h2><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
<p>思路：</p>
<p>+ </p>
<h2 id="3、K个一组翻转链表"><a href="#3、K个一组翻转链表" class="headerlink" title="3、K个一组翻转链表"></a>3、K个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">https://leetcode.cn/problems/reverse-nodes-in-k-group</a></p>
<p>思路：</p>
<ul>
<li>由于第一个节点也是需要翻转的，所以需要先创建一个虚拟头节点<code>virtualNode</code>，<code>virtualNode.next=head</code>。</li>
<li>之后要确定翻转链表的范围，且需要记录翻转部分的头节点的前驱结点以及翻转部分的尾结点的后继节点。因此定义一个<code>pre</code>指针，该指针指向需要翻转的链表的头节点的前驱结点。定义一个<code>end</code>指针指向需要翻转的链表的尾结点。那么<code>end.next</code>就是需要翻转的链表的尾节点的后继节点。初始时，<code>pre</code>、<code>end</code>均指向<code>virtualNode</code>，相当于初始时，<code>pre</code>、<code>end</code>都先指向需要翻转的链表的头节点的前驱结点。</li>
<li>由于K个一组翻转，所以需要先将<code>end</code>移动到一组当中的第K个节点处。即<code>end</code>先走K步。这里需要注意的是，<code>end</code>不能为<code>null</code>。如果<code>end</code>为<code>null</code>，说明剩余链表长度无法达到K个，则不用翻转了。</li>
<li>当<code>end</code>走到指定位置后，定义一个<code>start</code>指针指向需要翻转的链表的头节点，即<code>pre.next</code>。定义一个<code>next</code>指针指向需要翻转的链表的尾节点的后继节点，即<code>end.next</code>。</li>
<li>然后让<code>pre.next=null</code>，<code>end.next=null</code>，进行断链，然后进行翻转链表操作。</li>
<li>之后让<code>pre.next</code>指向翻转之后的链表的头节点。即<code>pre.next = reverse(start)</code>。因此这里可以进行简写，把上面的<code>pre.next = null</code>去掉。由于翻转之前<code>start</code>指向头节点，那么翻转之后就指向尾节点了，所以让<code>start.next = next</code>，将其与后面的链表进行重连。</li>
<li>然后更新<code>pre</code>、<code>end</code>指针的位置，使其重新指向需要进行翻转的链表的头节点的前驱节点，准备进行下一次翻转操作。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/866b404c6b0b52fa02385e301ee907fc015742c3766c80c02e24ef3a8613e5ad-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        virtualNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> virtualNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特殊情况，反转部分长度不足k时，定位完成end后，end会为null。</span></span><br><span class="line">            <span class="comment">// 所以要判断一下，如果为null了，直接跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试题汇总（二）</title>
    <url>/2023/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、TCP与UDP的区别"><a href="#一、TCP与UDP的区别" class="headerlink" title="一、TCP与UDP的区别"></a>一、TCP与UDP的区别</h1><ul>
<li><strong>是否面向连接：</strong>TCP是面向连接的，即传输数据之前，需要先与服务端通过“三次握手”建立连接，数据传输完成后，通过“四次挥手”释放连接。而UDP则是无连接的，可以直接进行数据的传输。</li>
<li><strong>传输是否可靠：</strong>TCP由于具有“三次握手”、“四次挥手”、流量控制、拥塞控制、超时重传、确认等机制，保证了TCP的传输是可靠的，即无差错、不丢失、不重复、按序到达。而UDP不具有上述机制，因此传输是不可靠的。</li>
<li><strong>是否具有状态：</strong>TCP传输是有状态的，即TCP会去记录自己发送消息的状态。比如：消息是否发送了、消息是否被接收了等。因此，TCP会维持一个复杂的连接状态表。而UDP传输是无状态的。</li>
<li><strong>首部开销：</strong>TCP的首部开销为20个字节，UDP的首部开销8个字节。</li>
<li><strong>传输形式：</strong>TCP是基于字节流进行传输，而UDP是基于报文进行传输。</li>
<li><strong>传输效率：</strong>由于TCP具有各种各样的机制来保证其传输的可靠性，因此传输效率比UDP低很多。</li>
<li><strong>是否支持广播或多播服务：</strong>TCP只支持一对一（点对点）通信，而UDP既支持一对一通信，也支持一对多、多对一、多对多通信。</li>
<li><strong>应用场景：</strong>TCP主要用于严格保证数据可靠传输的场景，例如：文件、邮件传输。而UDP主要用于追求实时性，即便丢失一些数据也无关紧要的场景，例如：直播、语音、视频、游戏等。</li>
</ul>
<h1 id="二、TCP和UDP首部的格式"><a href="#二、TCP和UDP首部的格式" class="headerlink" title="二、TCP和UDP首部的格式"></a>二、TCP和UDP首部的格式</h1><p>UDP首部由源端口号、目标端口号、包长度、校验和组成。</p>
<ul>
<li><strong>源端口号（Source Port）：</strong>表示发送端端口号，字段长16位（2字节）。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候，该字段的值设置为0。</li>
<li><strong>目标端口号（Destination Port）：</strong>表示接收端端口号，字段长16位（2字节）。</li>
<li><strong>包长度（Length）：</strong>该字段保存了UDP首部的长度与数据的长度之和，单位为字节。</li>
<li><strong>校验和（Checksum）：</strong>校验和是为了提供可靠的UDP首部和数据而设计的。包括校验和字段在内的所有数据之和结果为“16位全部为1”时，才会被认为所收到的数据是正确的。</li>
</ul>
<blockquote>
<p>关于UDP首部校验和具体的计算逻辑，可以参考《图解TCP&#x2F;IP（第5版）》220页。</p>
</blockquote>
<p>TCP首部由源端口号、目标端口号、序列号、确认应答号、数据偏移、保留、控制位、窗口大小、校验和、紧急指针、选项、填充构成。</p>
<ul>
<li><p><strong>源端口号（Source Port）：</strong>表示发送端端口号，字段长16位（2字节）。</p>
</li>
<li><p><strong>目标端口号（Destination Port）：</strong>表示接收端端口号，字段长度16位（2字节）。</p>
</li>
<li><p><strong>序列号（Sequence Number）：</strong>指发送数据的位置，序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。每发送一次数据，就累加一次该数据字节数的大小。字段长32位（4字节）。</p>
</li>
<li><p><strong>确认应答号（Acknowledgement Number）：</strong>指下一次应该收到的数据的序列号，字段长度32位（4字节）。实际上，可以将其理解为发送端收到这个确认应答以后，可以认为在这个序号以前的数据都已经被正确接收。</p>
</li>
<li><p><strong>数据偏移（Data Offset）：</strong>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作TCP首部的长度。字段长4位，单位为4字节。</p>
</li>
<li><p><strong>保留（Reserved）：</strong>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即时收到的包中该字段不为0，此包也不会被丢弃。</p>
</li>
<li><p><strong>控制位（Control Flag）：</strong>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫作控制位。当他们对应位上的值为1时，具有不同的含义。例如：CWR标志和ECE标志都用于IP首部的ECN字段，ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<blockquote>
<p>关于控制位值为1时具体的含义，可以参考《图解TCP&#x2F;IP（第5版）》223页。</p>
</blockquote>
</li>
<li><p><strong>窗口大小（Window Size）：</strong>用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小，该字段长16位（2字节）。TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小，但这个探测数据必须是1字节。</p>
</li>
<li><p><strong>校验和（Checksum）：</strong>与UDP类似，区别在于TCP的校验和无法关闭。</p>
<blockquote>
<p>关于TCP首部校验和具体的计算逻辑，可以参考《图解TCP&#x2F;IP（第5版）》224页。</p>
</blockquote>
</li>
<li><p><strong>紧急指针（Urgent Pointer）：</strong>该字段长16位（2字节）。只有在URG控制位为1时有效。该字段表示本报文段中紧急数据的指针，即从数据部分的首位到紧急指针所指示的位置为紧急数据。</p>
</li>
<li><p><strong>选项（Options）：</strong>该字段用于提高TCP的传输性能。长度最大为40字节。</p>
<blockquote>
<p>关于每个选项字段具体的含义，可以参考《图解TCP&#x2F;IP（第5版）》225页。</p>
</blockquote>
</li>
</ul>
<h1 id="三、HTTP是基于TCP还是UDP的？"><a href="#三、HTTP是基于TCP还是UDP的？" class="headerlink" title="三、HTTP是基于TCP还是UDP的？"></a>三、HTTP是基于TCP还是UDP的？</h1><p>HTTP&#x2F;3.0之前是基于TCP协议的，而HTTP&#x2F;3.0弃用TCP，改用基于UDP的QUIC协议。主要目的是解决HTTP&#x2F;2.0中存在的队头阻塞问题。由于HTTP&#x2F;2.0在单个TCP连接上使用了多路复用技术，受到TCP拥塞控制的影响，少量的丢包就可能导致整个TCP连接上的所有流被阻塞。此外，HTTP&#x2F;2.0需要经过“三次握手”的过程建立连接，一般是3个RTT（往返时延），而借助QUIC协议的特性，HTTP&#x2F;3.0可以避免TCP的三次握手的延迟，允许在第一次连接时发送数据（0个RTT）。</p>
<h1 id="四、TCP的三次握手"><a href="#四、TCP的三次握手" class="headerlink" title="四、TCP的三次握手"></a>四、TCP的三次握手</h1><p><img src="/img/article_content_img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<p><strong>第一次握手：</strong>客户端将自己的SYN设置为1，并随机生成一个客户端的初始序列号（Sequence Number）发送给服务端，然后客户端进入<em>SYN_SENT</em>状态。</p>
<p><strong>第二次握手：</strong>服务端收到客户端发来的SYN&#x3D;1之后，就知道客户端此时想要建立连接了。此时服务端将自己的SYN与ACK都设置为1，并随机生成一个确认应答号（Acknowledgement Number），确认应答号的值为客户端传过来的初始序列号的值加一，即Acknowledgement Number &#x3D; Sequence Number + 1。之后随机生成一个服务端的初始序列号（Sequence Number），将SYN、ACK、Acknowledgement Number、Sequence Number一并发送给客户端，然后服务端进入<em>SYN_RECV</em>状态。</p>
<p><strong>第三次握手：</strong>客户端收到服务端发回的信息后，验证Acknowledgement Number是否为自己的初始序列号的值加一，验证通过后，客户端将自己的ACK设置为1，并生成一个确认应答号（Acknowledgement Number），该值等于服务端传过来的初始序列号的值加一，然后将ACK与Acknowledgement Number发送给服务端，此时客户端进入<em>Establish</em>状态。服务端收到客户端传过来的信息后，验证Acknowledgement Number是否为自己的初始序列号的值加一，若验证通过，则服务端也进入<em>Establish</em>状态。</p>
<p>自此，连接建立完成，三次握手结束。</p>
<h1 id="五、为什么TCP连接时三次握手，而不是两次或者四次？"><a href="#五、为什么TCP连接时三次握手，而不是两次或者四次？" class="headerlink" title="五、为什么TCP连接时三次握手，而不是两次或者四次？"></a>五、为什么TCP连接时三次握手，而不是两次或者四次？</h1>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
